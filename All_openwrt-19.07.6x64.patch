--- a/target/linux/sunxi/config-4.14	2021-03-02 21:21:50.746649436 +0200
+++ b/target/linux/sunxi/config-4.14	2021-01-26 20:23:25.570905130 +0200
@@ -40,7 +40,9 @@
 CONFIG_ARM_ATAG_DTB_COMPAT=y
 # CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND is not set
 CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_FROM_BOOTLOADER=y
+CONFIG_ARM_BIG_LITTLE_CPUFREQ=y
 CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARM_DT_BL_CPUFREQ=y
 CONFIG_ARM_ERRATA_643719=y
 CONFIG_ARM_GIC=y
 CONFIG_ARM_HAS_SG_CHAIN=y
@@ -64,15 +66,16 @@
 CONFIG_AXP20X_POWER=y
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
 CONFIG_BACKLIGHT_LCD_SUPPORT=y
-CONFIG_BACKLIGHT_PWM=y
 CONFIG_BLK_DEV_LOOP=y
 CONFIG_BLK_DEV_SD=y
 CONFIG_BLK_SCSI_REQUEST=y
 CONFIG_BOUNCE=y
+CONFIG_BUILD_BIN2C=y
 CONFIG_CACHE_L2X0=y
 CONFIG_CAN=y
 CONFIG_CLKDEV_LOOKUP=y
 CONFIG_CLKSRC_MMIO=y
+CONFIG_CLOCK_THERMAL=y
 CONFIG_CLONE_BACKWARDS=y
 CONFIG_COMMON_CLK=y
 CONFIG_CONFIGFS_FS=y
@@ -93,14 +96,15 @@
 CONFIG_CPU_CP15=y
 CONFIG_CPU_CP15_MMU=y
 CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
 CONFIG_CPU_FREQ_GOV_ATTR_SET=y
 CONFIG_CPU_FREQ_GOV_COMMON=y
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
 CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=y
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
 CONFIG_CPU_FREQ_STAT=y
 CONFIG_CPU_HAS_ASID=y
 # CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
@@ -205,6 +209,7 @@
 CONFIG_GENERIC_IO=y
 CONFIG_GENERIC_IRQ_CHIP=y
 CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
 CONFIG_GENERIC_IRQ_SHOW=y
 CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
 CONFIG_GENERIC_PCI_IOMAP=y
@@ -294,10 +299,10 @@
 CONFIG_I2C_COMPAT=y
 CONFIG_I2C_HELPER_AUTO=y
 CONFIG_I2C_MV64XXX=y
-CONFIG_I2C_SUN6I_P2WI=y
 CONFIG_IIO=y
 # CONFIG_IIO_BUFFER is not set
 # CONFIG_IIO_TRIGGER is not set
+CONFIG_IKCONFIG=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_INPUT=y
 CONFIG_INPUT_AXP20X_PEK=y
@@ -314,6 +319,21 @@
 CONFIG_IRQ_DOMAIN_HIERARCHY=y
 CONFIG_IRQ_FORCED_THREADING=y
 CONFIG_IRQ_WORK=y
+# CONFIG_IR_GPIO_TX is not set
+CONFIG_IR_JVC_DECODER=m
+CONFIG_IR_LIRC_CODEC=m
+CONFIG_IR_MCE_KBD_DECODER=m
+CONFIG_IR_NEC_DECODER=m
+CONFIG_IR_RC5_DECODER=m
+CONFIG_IR_RC6_DECODER=m
+CONFIG_IR_SANYO_DECODER=m
+# CONFIG_IR_SERIAL is not set
+CONFIG_IR_SHARP_DECODER=m
+# CONFIG_IR_SIR is not set
+CONFIG_IR_SONY_DECODER=m
+# CONFIG_IR_SPI is not set
+CONFIG_IR_SUNXI=m
+CONFIG_IR_XMP_DECODER=m
 CONFIG_JBD2=y
 CONFIG_KALLSYMS=y
 # CONFIG_KERNEL_MODE_NEON is not set
@@ -328,6 +348,7 @@
 CONFIG_LCD_PLATFORM=y
 CONFIG_LEDS_GPIO=y
 CONFIG_LIBFDT=y
+CONFIG_LIRC=m
 CONFIG_LOCK_SPIN_ON_OWNER=y
 CONFIG_LOGO=y
 CONFIG_LOGO_LINUX_CLUT224=y
@@ -346,9 +367,9 @@
 CONFIG_MEDIA_SUPPORT=y
 # CONFIG_MFD_AC100 is not set
 CONFIG_MFD_AXP20X=y
-CONFIG_MFD_AXP20X_I2C=y
 CONFIG_MFD_AXP20X_RSB=y
 CONFIG_MFD_CORE=y
+# CONFIG_MFD_SUN4I_GPADC is not set
 CONFIG_MFD_SUN6I_PRCM=y
 CONFIG_MFD_SYSCON=y
 CONFIG_MIGHT_HAVE_CACHE_L2X0=y
@@ -360,14 +381,16 @@
 CONFIG_MMU_NOTIFIER=y
 CONFIG_MODULES_TREE_LOOKUP=y
 CONFIG_MODULES_USE_ELF_REL=y
-CONFIG_MTD=y
-CONFIG_MTD_SPLIT_SUPPORT=y
-CONFIG_MTD_SPLIT_FIT_FW=y
-CONFIG_MTD_OF_PARTS=y
-CONFIG_MTD_JEDECPROBE=y
 # CONFIG_MTD_IMPA7 is not set
+CONFIG_MTD_JEDECPROBE=y
 CONFIG_MTD_M25P80=y
 CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_SPLIT_FIRMWARE=y
+CONFIG_MTD_SPLIT_SUPPORT=y
+CONFIG_MTD_SPLIT_FIT_FW=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
+CONFIG_MTD_OF_PARTS=y
 CONFIG_MULTI_IRQ_HANDLER=y
 CONFIG_MUTEX_SPIN_ON_OWNER=y
 CONFIG_NEED_DMA_MAP_STATE=y
@@ -378,6 +401,7 @@
 CONFIG_NLS=y
 CONFIG_NLS_CODEPAGE_437=y
 CONFIG_NLS_ISO8859_1=y
+CONFIG_NOP_USB_XCEIV=y
 CONFIG_NO_BOOTMEM=y
 CONFIG_NO_HZ=y
 CONFIG_NO_HZ_COMMON=y
@@ -452,13 +476,14 @@
 CONFIG_PROC_EVENTS=y
 CONFIG_PROC_PAGE_MONITOR=y
 CONFIG_PTP_1588_CLOCK=y
-CONFIG_PWM=y
-CONFIG_PWM_SUN4I=y
-CONFIG_PWM_SYSFS=y
 CONFIG_RATIONAL=y
 # CONFIG_RCU_BOOST is not set
 CONFIG_RCU_NEED_SEGCBLIST=y
 CONFIG_RCU_STALL_COMMON=y
+CONFIG_RC_CORE=m
+CONFIG_RC_DECODERS=y
+CONFIG_RC_DEVICES=y
+CONFIG_RC_MAP=m
 CONFIG_REGMAP=y
 CONFIG_REGMAP_I2C=y
 CONFIG_REGMAP_IRQ=y
@@ -498,16 +523,18 @@
 CONFIG_SND_PCM=y
 CONFIG_SND_SOC=y
 CONFIG_SND_SOC_I2C_AND_SPI=y
-# CONFIG_SND_SUN4I_I2S is not set
-# CONFIG_SND_SUN4I_SPDIF is not set
-# CONFIG_SND_SUN8I_CODEC is not set
-# CONFIG_SND_SUN8I_CODEC_ANALOG is not set
+CONFIG_SND_SUN4I_CODEC=y
+CONFIG_SND_SUN8I_CODEC=y
+CONFIG_SND_SUN8I_CODEC_ANALOG=y
+CONFIG_SND_SUN4I_SPDIF=y
+CONFIG_SND_SUN4I_I2S=y
 CONFIG_SOUND=y
 CONFIG_SOUND_OSS_CORE=y
 # CONFIG_SOUND_OSS_CORE_PRECLAIM is not set
 CONFIG_SPARSE_IRQ=y
 CONFIG_SPI=y
 CONFIG_SPI_MASTER=y
+CONFIG_SPI_SPIDEV=y
 CONFIG_SPI_SUN4I=y
 CONFIG_SPI_SUN6I=y
 CONFIG_SRCU=y
@@ -515,7 +542,9 @@
 CONFIG_STMMAC_PLATFORM=y
 CONFIG_SUN4I_A10_CCU=y
 # CONFIG_SUN4I_EMAC is not set
+CONFIG_SUN4I_GPADC=y
 CONFIG_SUN4I_TIMER=y
+# CONFIG_SUN50I_H6_THS is not set
 CONFIG_SUN5I_CCU=y
 CONFIG_SUN5I_HSTIMER=y
 CONFIG_SUN6I_A31_CCU=y
@@ -526,6 +555,7 @@
 CONFIG_SUN8I_H3_CCU=y
 CONFIG_SUN8I_R40_CCU=y
 CONFIG_SUN8I_R_CCU=y
+CONFIG_SUN8I_THS=y
 CONFIG_SUN8I_V3S_CCU=y
 CONFIG_SUN9I_A80_CCU=y
 CONFIG_SUNXI_CCU=y
@@ -548,35 +578,53 @@
 CONFIG_SYS_SUPPORTS_HUGETLBFS=y
 CONFIG_TASKS_RCU=y
 CONFIG_THERMAL=y
-CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
 CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
+CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE=y
+# CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE is not set
+CONFIG_THERMAL_GOV_BANG_BANG=y
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
 CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
 CONFIG_THERMAL_HWMON=y
 CONFIG_THERMAL_OF=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_GENERIC_ADC_THERMAL=y
 # CONFIG_THUMB2_KERNEL is not set
 CONFIG_TICK_CPU_ACCOUNTING=y
 CONFIG_TIMER_OF=y
 CONFIG_TIMER_PROBE=y
 CONFIG_TMPFS_POSIX_ACL=y
 CONFIG_TOUCHSCREEN_PROPERTIES=y
-CONFIG_TOUCHSCREEN_SUN4I=y
+CONFIG_TOUCHSCREEN_SUN4I=m
 CONFIG_TREE_SRCU=y
 CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
 CONFIG_UNINLINE_SPIN_UNLOCK=y
 CONFIG_USB=y
+CONFIG_USB_ACM=m
 CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+# CONFIG_USB_AUDIO is not set
 CONFIG_USB_COMMON=y
 CONFIG_USB_DWC2=y
 CONFIG_USB_DWC2_HOST=y
 # CONFIG_USB_DWC2_TRACK_MISSED_SOFS is not set
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_ETH=y
+# CONFIG_USB_ETH_EEM is not set
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_USB_F_ECM=y
+CONFIG_USB_F_RNDIS=y
+CONFIG_USB_F_SUBSET=y
 CONFIG_USB_GADGET=y
+CONFIG_USB_LIBCOMPOSITE=y
 CONFIG_USB_NET_DRIVERS=y
 CONFIG_USB_OHCI_HCD=y
 CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_PHY=y
 CONFIG_USB_STORAGE=y
 CONFIG_USB_SUPPORT=y
+CONFIG_USB_U_ETHER=y
 CONFIG_USERIO=y
 CONFIG_USE_OF=y
 CONFIG_VDSO=y
@@ -592,7 +640,12 @@
 CONFIG_VT_CONSOLE=y
 CONFIG_VT_CONSOLE_SLEEP=y
 CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_W1=m
+CONFIG_W1_MASTER_GPIO=m
 CONFIG_WATCHDOG_CORE=y
+CONFIG_PWM=y
+CONFIG_PWM_SYSFS=y
+CONFIG_PWM_SUN4I=y
 # CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
 CONFIG_XPS=y
 CONFIG_XZ_DEC_ARM=y
--- a/target/linux/sunxi/modules.mk	2021-03-02 21:21:50.746649436 +0200
+++ b/target/linux/sunxi/modules.mk	2021-01-22 00:11:49.808136915 +0200
@@ -25,15 +25,55 @@
 define KernelPackage/sunxi-ir
     SUBMENU:=$(OTHER_MENU)
     TITLE:=Sunxi SoC built-in IR support (A20)
-    DEPENDS:=@TARGET_sunxi +kmod-input-core
+    DEPENDS:=@TARGET_sunxi +kmod-input-core +v4l-utils +triggerhappy
     $(call AddDepends/rtc)
     KCONFIG:= \
 	CONFIG_MEDIA_SUPPORT=y \
 	CONFIG_MEDIA_RC_SUPPORT=y \
 	CONFIG_RC_DEVICES=y \
-	CONFIG_IR_SUNXI
-    FILES:=$(LINUX_DIR)/drivers/media/rc/sunxi-cir.ko
-    AUTOLOAD:=$(call AutoLoad,50,sunxi-cir)
+	CONFIG_IR_SUNXI \
+	CONFIG_RC_DECODERS=y \
+	CONFIG_RC_CORE=m \
+	CONFIG_RC_MAP=m \
+	CONFIG_LIRC=y \
+	CONFIG_BPF_LIRC_MODE2=y \
+	CONFIG_IR_NEC_DECODER=m \
+	CONFIG_IR_RC5_DECODER=m \
+	CONFIG_IR_RC6_DECODER=m \
+	CONFIG_IR_JVC_DECODER=m \
+	CONFIG_IR_SONY_DECODER=m \
+	CONFIG_IR_SANYO_DECODER=m \
+	CONFIG_IR_SHARP_DECODER=m \
+	CONFIG_IR_MCE_KBD_DECODER=m \
+	CONFIG_IR_XMP_DECODER=m \
+	CONFIG_IR_IMON_DECODER=m \
+	CONFIG_IR_IMON_RAW=m \
+	CONFIG_IR_SPI=m \
+	CONFIG_IR_PWM_TX=m \
+	CONFIG_IR_SERIAL=m \
+	CONFIG_IR_SERIAL_TRANSMITTER=y \
+	CONFIG_IR_SIR=m \
+	CONFIG_IR_GPIO_TX=m
+    FILES:= \
+	$(LINUX_DIR)/drivers/media/rc/gpio-ir-tx.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-jvc-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-mce_kbd-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-nec-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-rc5-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-rc6-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-sanyo-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-sharp-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-sony-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-spi.ko \
+	$(LINUX_DIR)/drivers/media/rc/ir-xmp-decoder.ko \
+	$(LINUX_DIR)/drivers/media/rc/lirc_dev.ko \
+	$(LINUX_DIR)/drivers/media/rc/pwm-ir-tx.ko \
+	$(LINUX_DIR)/drivers/media/rc/rc-core.ko \
+	$(LINUX_DIR)/drivers/media/rc/serial_ir.ko \
+	$(LINUX_DIR)/drivers/media/rc/sir_ir.ko \
+	$(LINUX_DIR)/drivers/media/rc/sunxi-cir.ko \
+	$(LINUX_DIR)/drivers/media/rc/keymaps/*.ko
+    AUTOLOAD:=$(call AutoLoad,80,sunxi-cir ir-nec-decoder)
 endef
 
 define KernelPackage/sunxi-ir/description
@@ -69,17 +109,293 @@
 $(eval $(call KernelPackage,sun4i-emac))
 
 
-define KernelPackage/sound-soc-sunxi
-  TITLE:=AllWinner built-in SoC sound support
+define KernelPackage/sound-soc-sun4i-codec
+  TITLE:=AllWinner built-in SoC sound support sun4i-codec
   KCONFIG:=CONFIG_SND_SUN4I_CODEC
   FILES:=$(LINUX_DIR)/sound/soc/sunxi/sun4i-codec.ko
-  AUTOLOAD:=$(call AutoLoad,65,sun4i-codec)
+  AUTOLOAD:=$(call AutoLoad,63,sun4i-codec)
   DEPENDS:=@TARGET_sunxi +kmod-sound-soc-core
   $(call AddDepends/sound)
 endef
 
-define KernelPackage/sound-soc-sunxi/description
-  Kernel support for AllWinner built-in SoC audio
+define KernelPackage/sound-soc-sun4i-codec/description
+  Kernel support for AllWinner built-in SoC audio sun4i-codec
 endef
 
-$(eval $(call KernelPackage,sound-soc-sunxi))
+$(eval $(call KernelPackage,sound-soc-sun4i-codec))
+
+
+define KernelPackage/sound-soc-sun8i-codec
+  TITLE:=AllWinner SoC sound sun8i-codec
+  KCONFIG:=CONFIG_SND_SUN8I_CODEC
+  FILES:=$(LINUX_DIR)/sound/soc/sunxi/sun8i-codec.ko
+  AUTOLOAD:=$(call AutoLoad,65,sun8i-codec)
+  DEPENDS:=@TARGET_sunxi +kmod-sound-soc-core
+  $(call AddDepends/sound)
+endef
+
+define KernelPackage/sound-soc-sun8i-codec/description
+  Kernel support for AllWinner built-in SoC audio sun8i-codec
+endef
+
+$(eval $(call KernelPackage,sound-soc-sun8i-codec))
+
+
+define KernelPackage/sound-soc-sun8i-codec-analog
+  TITLE:=AllWinner SoC sound sun8i-codec-analog
+  KCONFIG:=CONFIG_SND_SUN8I_CODEC_ANALOG
+  FILES:=$(LINUX_DIR)/sound/soc/sunxi/sun8i-codec-analog.ko
+  AUTOLOAD:=$(call AutoLoad,67,sun8i-codec-analog)
+  DEPENDS:=@TARGET_sunxi +kmod-sound-soc-core
+  $(call AddDepends/sound)
+endef
+
+define KernelPackage/sound-soc-sun8i-codec-analog/description
+  Kernel support for AllWinner built-in SoC audio sun8i-codec-analog
+endef
+
+$(eval $(call KernelPackage,sound-soc-sun8i-codec-analog))
+
+
+define KernelPackage/sound-soc-sun4i-i2s
+  TITLE:=AllWinner SoC sound sun4i-i2s
+  KCONFIG:=CONFIG_SND_SUN4I_I2S
+  FILES:=$(LINUX_DIR)/sound/soc/sunxi/sun4i-i2s.ko
+  AUTOLOAD:=$(call AutoLoad,67,sun4i-i2s)
+  DEPENDS:=@TARGET_sunxi +kmod-sound-soc-core
+  $(call AddDepends/sound)
+endef
+
+define KernelPackage/sound-soc-sun4i-i2s/description
+  Kernel support for AllWinner built-in SoC audio sun4i-i2s
+endef
+
+$(eval $(call KernelPackage,sound-soc-sun4i-i2s))
+
+
+define KernelPackage/sound-soc-sun4i-spdif
+  TITLE:=AllWinner SoC sound sun4i-spdif
+  KCONFIG:=CONFIG_SND_SUN4I_SPDIF
+  FILES:=$(LINUX_DIR)/sound/soc/sunxi/sun4i-spdif.ko
+  AUTOLOAD:=$(call AutoLoad,67,sun4i-spdif)
+  DEPENDS:=@TARGET_sunxi +kmod-sound-soc-core
+  $(call AddDepends/sound)
+endef
+
+define KernelPackage/sound-soc-sun4i-spdif/description
+  Kernel support for AllWinner built-in SoC audio sun4i-spdif
+endef
+
+$(eval $(call KernelPackage,sound-soc-sun4i-spdif))
+
+###################################################################
+define KernelPackage/thermal-sunxi
+  SUBMENU:=Sunxi Thermal
+  TITLE:=Generic Thermal sysfs driver
+  DEPENDS:=@TARGET_sunxi +kmod-hwmon-core
+  KCONFIG:= \
+	CONFIG_THERMAL=m \
+	CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE=n \
+	CONFIG_THERMAL_GOV_USER_SPACE=n \
+	CONFIG_THERMAL_EMULATION=n
+  FILES:= \
+	$(LINUX_DIR)/drivers/thermal/thermal_sys.ko
+  AUTOLOAD:=$(call AutoProbe,thermal_sys)
+endef
+
+define KernelPackage/thermal/description
+ Generic Thermal Sysfs driver offers a generic mechanism for thermal
+ management. Usually it's made up of one or more thermal zone and cooling
+ device.
+endef
+
+$(eval $(call KernelPackage,thermal-sunxi))
+
+
+define KernelPackage/sun4i-gpadc-iio
+  SUBMENU:=Sunxi Thermal
+  TITLE:=Generic sun4i-gpadc-iio driver
+  DEPENDS:=@TARGET_sunxi +kmod-thermal-sunxi
+  KCONFIG:=CONFIG_SUN4I_GPADC=y \
+	CONFIG_MFD_SUN4I_GPADC=n
+  FILES:= \
+	$(LINUX_DIR)/drivers/iio/adc/sun4i-gpadc-iio.ko
+  AUTOLOAD:=$(call AutoProbe,sun4i-gpadc-iio)
+endef
+
+$(eval $(call KernelPackage,sun4i-gpadc-iio))
+
+
+define KernelPackage/sun8i_ths
+  SUBMENU:=Sunxi Thermal
+  TITLE:=Generic SUN8I_THS driver
+  DEPENDS:=@TARGET_sunxi +kmod-thermal-sunxi
+  KCONFIG:=CONFIG_SUN8I_THS=m
+  FILES:=$(LINUX_DIR)/drivers/thermal/sun8i_ths.ko
+  AUTOLOAD:=$(call AutoProbe,sun8i_ths)
+endef
+
+define KernelPackage/thermal/description
+ Generic SUN8I_THS driver offers a generic mechanism for thermal
+ management. Usually it's made up of one or more thermal zone and cooling
+ device.
+endef
+
+$(eval $(call KernelPackage,sun8i_ths))
+
+
+define KernelPackage/sun50i_h6_ths
+  SUBMENU:=Sunxi Thermal
+  TITLE:=Generic SUN50I_H6_THS driver
+  DEPENDS:=@TARGET_sunxi +kmod-thermal-sunxi
+  KCONFIG:=CONFIG_SUN50I_H6_THS=m
+  FILES:=$(LINUX_DIR)/drivers/thermal/sun50i_h6_ths.ko
+  AUTOLOAD:=$(call AutoProbe,sun50i_h6_ths)
+endef
+
+define KernelPackage/thermal/description
+ Generic SUN50I_H6_THS driver offers a generic mechanism for thermal
+ management. Usually it's made up of one or more thermal zone and cooling
+ device.
+endef
+
+$(eval $(call KernelPackage,sun50i_h6_ths))
+
+
+define KernelPackage/thermal-generic-adc
+  SUBMENU:=Sunxi Thermal
+  TITLE:=Generic GENERIC_ADC_THERMAL driver
+  DEPENDS:=@TARGET_sunxi +kmod-thermal-sunxi
+  KCONFIG:=CONFIG_GENERIC_ADC_THERMAL=m
+  FILES:=$(LINUX_DIR)/drivers/thermal/thermal-generic-adc.ko
+  AUTOLOAD:=$(call AutoProbe,thermal-generic-adc)
+endef
+
+$(eval $(call KernelPackage,thermal-generic-adc))
+
+
+define KernelPackage/arm_big_little
+  SUBMENU:=$(OTHER_MENU)
+  TITLE:=Generic arm_big_little driver
+  DEPENDS:=@TARGET_sunxi +kmod-thermal-sunxi
+  KCONFIG:=CONFIG_ARM_BIG_LITTLE_CPUFREQ=y
+  FILES:=$(LINUX_DIR)/drivers/cpufreq/arm_big_little.ko
+  AUTOLOAD:=$(call AutoProbe,arm_big_little)
+endef
+
+$(eval $(call KernelPackage,arm_big_little))
+
+
+define KernelPackage/arm_big_little_dt
+  SUBMENU:=$(OTHER_MENU)
+  TITLE:=This enables the Generic CPUfreq driver for ARM big.LITTLE platforms.
+  DEPENDS:=@TARGET_sunxi +kmod-thermal-sunxi +kmod-arm_big_little
+  KCONFIG:=CONFIG_ARM_DT_BL_CPUFREQ=y
+  FILES:=$(LINUX_DIR)/drivers/cpufreq/arm_big_little_dt.ko
+  AUTOLOAD:=$(call AutoProbe,arm_big_little_dt)
+endef
+
+$(eval $(call KernelPackage,arm_big_little_dt))
+
+
+define KernelPackage/cpufreq-dt
+  SUBMENU:=$(OTHER_MENU)
+  TITLE:=Generic cpufreq-dt driver
+  DEPENDS:=@TARGET_sunxi +kmod-thermal-sunxi
+  KCONFIG:=CONFIG_CPUFREQ_DT_PLATDEV=y
+  FILES:=$(LINUX_DIR)/drivers/cpufreq/cpufreq-dt.ko
+  AUTOLOAD:=$(call AutoProbe,cpufreq-dt)
+endef
+
+$(eval $(call KernelPackage,cpufreq-dt))
+###################################################################
+
+define KernelPackage/sunxi-i2c
+  SUBMENU:=I2C support
+  TITLE:=Generic sunxi-i2c driver
+  DEPENDS:=@TARGET_sunxi +kmod-i2c-core
+  KCONFIG:=CONFIG_I2C_SUN6I_P2WI=m \
+	CONFIG_I2C_MV64XXX=m
+  FILES:= \
+	$(LINUX_DIR)/drivers/i2c/busses/i2c-mv64xxx.ko
+  AUTOLOAD:=$(call AutoProbe,i2c-mv64xxx)
+endef
+
+define KernelPackage/sunxi-i2c/description
+ If you say yes to this option, support will be included for the
+ I2C interface from Allwinner Technology sunxi platform.
+ 
+ This driver can also be built as a module. If so, the module
+ will be called i2c-sun6i-p2wi, i2c-mv64xxx.
+endef
+
+$(eval $(call KernelPackage,sunxi-i2c))
+
+######### wireless drivers #########################
+#define KernelPackage/rtl8189es
+#  SUBMENU:=$(WIRELESS_MENU) Test-rtl8189es
+#  TITLE:=RTL8189es test wifi-drivers support
+#  KCONFIG:=CONFIG_RTL8189ES \
+#	CONFIG_WLAN_VENDOR_REALTEK=y
+#  FILES:=$(LINUX_DIR)/drivers/net/wireless/realtek/rtl8189es/8189es.ko
+#  DEPENDS:=@TARGET_sunxi +kmod-usb-core +kmod-usb-net +@DRIVER_11N_SUPPORT +@DRIVER_11AC_SUPPORT
+##  AUTOLOAD:=$(call AutoProbe,rtl8189es)
+#  AUTOLOAD:=$(call AutoLoad,50,8189es)
+#endef
+#
+#$(eval $(call KernelPackage,rtl8189es))
+#####################################################
+
+
+define KernelPackage/pwm-sun4i
+  SUBMENU:=$(OTHER_MENU)
+  TITLE:=Generic pwm-sun4i driver
+  DEPENDS:=@TARGET_sunxi
+  KCONFIG:= \
+	CONFIG_PWM=y \
+	CONFIG_PWM_SYSFS=y \
+	CONFIG_PWM_SUN4I=m
+  FILES:=$(LINUX_DIR)/drivers/pwm/pwm-sun4i.ko
+  AUTOLOAD:=$(call AutoProbe,pwm-sun4i)
+endef
+
+$(eval $(call KernelPackage,pwm-sun4i))
+
+
+define KernelPackage/pwm-regulator
+  SUBMENU:=$(OTHER_MENU)
+  TITLE:=Generic pwm-regulator driver
+  DEPENDS:=@TARGET_sunxi
+  KCONFIG:= \
+	CONFIG_REGULATOR_PWM=m
+  FILES:=$(LINUX_DIR)/drivers/regulator/pwm-regulator.ko
+  AUTOLOAD:=$(call AutoProbe,pwm-regulator)
+endef
+
+$(eval $(call KernelPackage,pwm-regulator))
+
+
+define KernelPackage/clk-pwm
+  SUBMENU:=$(OTHER_MENU)
+  TITLE:=Generic clk-pwm driver
+  DEPENDS:=@TARGET_sunxi
+  KCONFIG:= \
+	CONFIG_COMMON_CLK_PWM=m
+  FILES:=$(LINUX_DIR)/drivers/clk/clk-pwm.ko
+  AUTOLOAD:=$(call AutoProbe,clk-pwm)
+endef
+
+$(eval $(call KernelPackage,clk-pwm))
+
+
+define KernelPackage/rotary_encoder
+  SUBMENU:=$(OTHER_MENU)
+  TITLE:=Generic rotary_encoder driver
+  DEPENDS:=@TARGET_sunxi +kmod-input-gpio-keys +triggerhappy
+  KCONFIG:= \
+	CONFIG_INPUT_GPIO_ROTARY_ENCODER=m
+  FILES:=$(LINUX_DIR)/drivers/input/misc/rotary_encoder.ko
+  AUTOLOAD:=$(call AutoProbe,rotary_encoder)
+endef
+
+$(eval $(call KernelPackage,rotary_encoder))
--- a/target/linux/sunxi/patches-4.14/202-add0-pinctrl_wifi-xr819-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/202-add0-pinctrl_wifi-xr819-opi-zero.patch	2021-01-22 00:11:49.808136915 +0200
@@ -0,0 +1,31 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -49,6 +49,7 @@
+ 
+ #include <dt-bindings/gpio/gpio.h>
+ #include <dt-bindings/input/input.h>
++#include <dt-bindings/pinctrl/sun4i-a10.h>
+ 
+ / {
+ 	model = "Xunlong Orange Pi Zero";
+@@ -128,7 +166,8 @@
+ 	mmc-pwrseq = <&wifi_pwrseq>;
+ 	bus-width = <4>;
+ 	non-removable;
+-	status = "okay";
++	keep-power-in-suspend;
++	status = "disabled";
+ 
+ 	/*
+ 	 * Explicitly define the sdio device, so that we can add an ethernet
+@@ -136,6 +166,10 @@
+ 	 */
+ 	xr819: sdio_wifi@1 {
+ 		reg = <1>;
++		compatible = "xradio,xr819";
++		interrupt-parent = <&pio>;
++		interrupts = <6 10 IRQ_TYPE_EDGE_RISING>;
++		interrupt-names = "host-wake";
+ 	};
+ };
+ 
--- a/target/linux/sunxi/patches-4.14/203-add-enable-soc_audio-routing-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/203-add-enable-soc_audio-routing-opi-zero.patch	2021-01-22 00:11:49.808136915 +0200
@@ -0,0 +1,14 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -156,6 +190,11 @@
+ &ohci1 {
+ 	status = "okay";
+ };
++
++&codec { /* add audio-routing */
++	allwinner,audio-routing = "Line Out", "LINEOUT", 
++				"MIC1", "Mic", "Mic", "MBIAS";
++};
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
--- a/target/linux/sunxi/patches-4.14/204-add-IR-pinctrl-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/204-add-IR-pinctrl-opi-zero.patch	2021-01-22 00:11:49.808136915 +0200
@@ -0,0 +1,15 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -161,6 +200,12 @@
+ 	allwinner,audio-routing = "Line Out", "LINEOUT", 
+ 				"MIC1", "Mic", "Mic", "MBIAS";
+ };
++
++&ir {
++	pinctrl-names = "default";
++	pinctrl-0 = <&ir_pins_a>;
++	status = "disabled";
++};
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
--- a/target/linux/sunxi/patches-4.14/205-add-w1-gpio_pinctrl-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/205-add-w1-gpio_pinctrl-opi-zero.patch	2021-01-22 00:11:49.808136915 +0200
@@ -0,0 +1,39 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -80,6 +90,18 @@
+ 			gpios = <&pio 0 17 GPIO_ACTIVE_HIGH>;
+ 		};
+ 	};
++
++	w1: w1 {
++		compatible = "w1-gpio";
++		/*
++		* PWM1/PA6 (PA06) pin on Orange Pi Zero gpio-6
++		* (0 this is A port, 6 this is gpio-6. for PD14 use  <&pio 3 14 GPIO_ACTIVE_HIGH>)
++		*/
++		gpios = <&pio 0 6 GPIO_ACTIVE_HIGH>;
++		pinctrl-names = "default";
++		pinctrl-0 = <&w1_pins>;
++		status = "disabled";
++	};
+ 
+ 	reg_vcc_wifi: reg_vcc_wifi {
+ 		compatible = "regulator-fixed";
+@@ -167,6 +200,17 @@
+ 	pinctrl-0 = <&ir_pins_a>;
+ 	status = "disabled";
+ };
++
++&pio {
++	w1_pins: w1_pins {
++		/*
++		* PWM1/PA6 (PA06) pin on Orange Pi Zero gpio-6
++		*/
++		pins = "PA6";
++		function = "gpio_in";	// in (initially)
++		pull = <0x00>;		// off
++	};
++};
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
--- a/target/linux/sunxi/patches-4.14/206-add-PA5-pwm_pin-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/206-add-PA5-pwm_pin-opi-zero.patch	2021-01-22 00:11:49.808136915 +0200
@@ -0,0 +1,22 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -189,7 +250,19 @@
+ 		function = "gpio_in";	// in (initially)
+ 		pull = <0x00>;		// off
+ 	};
++
++	pwm0_pin: pwm0 {
++		pins = "PA5";
++		function = "pwm0";
++		drive = <SUN4I_PINCTRL_10_MA>;
++		pull = <SUN4I_PINCTRL_NO_PULL>;
++	};
+ };
++
++&pwm {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pwm0_pin>;
++};
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
--- a/target/linux/sunxi/patches-4.14/207-add0-cpu-freg-ths.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/207-add0-cpu-freg-ths.patch	2021-01-22 00:11:49.808136915 +0200
@@ -0,0 +1,751 @@
+--- a/arch/arm/boot/dts/sun8i-h3.dtsi	2020-01-29 16:02:39.000000000 +0200
++++ b/arch/arm/boot/dts/sun8i-h3.dtsi	2020-02-01 11:37:12.000000000 +0200
+@@ -43,32 +43,77 @@
+ #include "sunxi-h3-h5.dtsi"
+ 
+ / {
++	cpu0_opp_table: opp_table0 {
++		compatible = "operating-points-v2";
++		opp-shared;
++
++		opp@480000000 {
++			opp-hz = /bits/ 64 <480000000>;
++			opp-microvolt = <1040000 1040000 1300000>;
++			clock-latency-ns = <244144>; /* 8 32k periods */
++		};
++
++		opp@648000000 {
++			opp-hz = /bits/ 64 <648000000>;
++			opp-microvolt = <1040000 1040000 1300000>;
++			clock-latency-ns = <244144>; /* 8 32k periods */
++		};
++
++		opp@816000000 {
++			opp-hz = /bits/ 64 <816000000>;
++			opp-microvolt = <1100000 1100000 1300000>;
++			clock-latency-ns = <244144>; /* 8 32k periods */
++		};
++
++		opp@1008000000 {
++			opp-hz = /bits/ 64 <1008000000>;
++			opp-microvolt = <1200000 1200000 1300000>;
++			clock-latency-ns = <244144>; /* 8 32k periods */
++		};
++	};
++
+ 	cpus {
+ 		#address-cells = <1>;
+ 		#size-cells = <0>;
+ 
+-		cpu@0 {
++		cpu0: cpu@0 {
+ 			compatible = "arm,cortex-a7";
+ 			device_type = "cpu";
+ 			reg = <0>;
++			clocks = <&ccu CLK_CPUX>;
++			clock-names = "cpu";
++			operating-points-v2 = <&cpu0_opp_table>;
++			#cooling-cells = <2>;
+ 		};
+ 
+ 		cpu@1 {
+ 			compatible = "arm,cortex-a7";
+ 			device_type = "cpu";
+ 			reg = <1>;
++			clocks = <&ccu CLK_CPUX>;
++			clock-names = "cpu";
++			operating-points-v2 = <&cpu0_opp_table>;
++			#cooling-cells = <2>;
+ 		};
+ 
+ 		cpu@2 {
+ 			compatible = "arm,cortex-a7";
+ 			device_type = "cpu";
+ 			reg = <2>;
++			clocks = <&ccu CLK_CPUX>;
++			clock-names = "cpu";
++			operating-points-v2 = <&cpu0_opp_table>;
++			#cooling-cells = <2>;
+ 		};
+ 
+ 		cpu@3 {
+ 			compatible = "arm,cortex-a7";
+ 			device_type = "cpu";
+ 			reg = <3>;
++			clocks = <&ccu CLK_CPUX>;
++			clock-names = "cpu";
++			operating-points-v2 = <&cpu0_opp_table>;
++			#cooling-cells = <2>;
+ 		};
+ 	};
+ 
+@@ -79,12 +118,65 @@
+ 			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+ 			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
+ 	};
++
++	soc {
++		system-control@1c00000 {
++			compatible = "allwinner,sun8i-h3-system-control";
++			reg = <0x01c00000 0x1000>;
++			#address-cells = <1>;
++			#size-cells = <1>;
++			ranges;
++
++			sram_c: sram@1d00000 {
++				compatible = "mmio-sram";
++				reg = <0x01d00000 0x80000>;
++				#address-cells = <1>;
++				#size-cells = <1>;
++				ranges = <0 0x01d00000 0x80000>;
++
++				ve_sram: sram-section@0 {
++					compatible = "allwinner,sun8i-h3-sram-c1",
++						     "allwinner,sun4i-a10-sram-c1";
++					reg = <0x000000 0x80000>;
++				};
++			};
++		};
++
++		mali: gpu@1c40000 {
++			compatible = "allwinner,sun8i-h3-mali", "arm,mali-400";
++			reg = <0x01c40000 0x10000>;
++			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>;
++			interrupt-names = "gp",
++					  "gpmmu",
++					  "pp0",
++					  "ppmmu0",
++					  "pp1",
++					  "ppmmu1",
++					  "pmu";
++			clocks = <&ccu CLK_BUS_GPU>, <&ccu CLK_GPU>;
++			clock-names = "bus", "core";
++			resets = <&ccu RST_BUS_GPU>;
++
++			assigned-clocks = <&ccu CLK_GPU>;
++			assigned-clock-rates = <384000000>;
++		};
++	};
+ };
+ 
+ &ccu {
+ 	compatible = "allwinner,sun8i-h3-ccu";
+ };
+ 
++&display_clocks {
++	compatible = "allwinner,sun8i-h3-de2-clk";
++};
++
+ &mmc0 {
+ 	compatible = "allwinner,sun7i-a20-mmc";
+ 	clocks = <&ccu CLK_BUS_MMC0>,
+--- a/arch/arm/boot/dts/sunxi-h3-h5.dtsi	2020-01-29 16:02:39.000000000 +0200
++++ b/arch/arm/boot/dts/sunxi-h3-h5.dtsi	2020-02-01 11:37:12.000000000 +0200
+@@ -40,9 +40,11 @@
+  *     OTHER DEALINGS IN THE SOFTWARE.
+  */
+ 
++#include <dt-bindings/clock/sun8i-de2.h>
+ #include <dt-bindings/clock/sun8i-h3-ccu.h>
+ #include <dt-bindings/clock/sun8i-r-ccu.h>
+ #include <dt-bindings/interrupt-controller/arm-gic.h>
++#include <dt-bindings/reset/sun8i-de2.h>
+ #include <dt-bindings/reset/sun8i-h3-ccu.h>
+ #include <dt-bindings/reset/sun8i-r-ccu.h>
+ 
+@@ -51,6 +53,30 @@
+ 	#address-cells = <1>;
+ 	#size-cells = <1>;
+ 
++	chosen {
++		#address-cells = <1>;
++		#size-cells = <1>;
++		ranges;
++
++		framebuffer-hdmi {
++			compatible = "allwinner,simple-framebuffer",
++				     "simple-framebuffer";
++			allwinner,pipeline = "mixer0-lcd0-hdmi";
++			clocks = <&display_clocks CLK_MIXER0>,
++				 <&ccu CLK_TCON0>, <&ccu CLK_HDMI>;
++			status = "disabled";
++		};
++
++		framebuffer-tve {
++			compatible = "allwinner,simple-framebuffer",
++				     "simple-framebuffer";
++			allwinner,pipeline = "mixer1-lcd1-tve";
++			clocks = <&display_clocks CLK_MIXER1>,
++				 <&ccu CLK_TVE>;
++			status = "disabled";
++		};
++	};
++
+ 	clocks {
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+@@ -79,19 +105,60 @@
+ 		};
+ 	};
+ 
++	de: display-engine {
++		compatible = "allwinner,sun8i-h3-display-engine";
++		allwinner,pipelines = <&mixer0>;
++		status = "disabled";
++	};
++
+ 	soc {
+ 		compatible = "simple-bus";
+ 		#address-cells = <1>;
+ 		#size-cells = <1>;
+ 		ranges;
+ 
++		display_clocks: clock@1000000 {
++			/* compatible is in per SoC .dtsi file */
++			reg = <0x01000000 0x100000>;
++			clocks = <&ccu CLK_DE>,
++				 <&ccu CLK_BUS_DE>;
++			clock-names = "mod",
++				      "bus";
++			resets = <&ccu RST_BUS_DE>;
++			#clock-cells = <1>;
++			#reset-cells = <1>;
++		};
++
++		mixer0: mixer@1100000 {
++			compatible = "allwinner,sun8i-h3-de2-mixer-0";
++			reg = <0x01100000 0x100000>;
++			clocks = <&display_clocks CLK_BUS_MIXER0>,
++				 <&display_clocks CLK_MIXER0>;
++			clock-names = "bus",
++				      "mod";
++			resets = <&display_clocks RST_MIXER0>;
++
++			ports {
++				#address-cells = <1>;
++				#size-cells = <0>;
++
++				mixer0_out: port@1 {
++					reg = <1>;
++
++					mixer0_out_tcon0: endpoint {
++						remote-endpoint = <&tcon0_in_mixer0>;
++					};
++				};
++			};
++		};
++
+ 		syscon: syscon@1c00000 {
+ 			compatible = "allwinner,sun8i-h3-system-controller",
+ 				"syscon";
+ 			reg = <0x01c00000 0x1000>;
+ 		};
+ 
+-		dma: dma-controller@01c02000 {
++		dma: dma-controller@1c02000 {
+ 			compatible = "allwinner,sun8i-h3-dma";
+ 			reg = <0x01c02000 0x1000>;
+ 			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+@@ -100,9 +167,46 @@
+ 			#dma-cells = <1>;
+ 		};
+ 
+-		mmc0: mmc@01c0f000 {
++		tcon0: lcd-controller@1c0c000 {
++			compatible = "allwinner,sun8i-h3-tcon-tv",
++				     "allwinner,sun8i-a83t-tcon-tv";
++			reg = <0x01c0c000 0x1000>;
++			interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&ccu CLK_BUS_TCON0>, <&ccu CLK_TCON0>;
++			clock-names = "ahb", "tcon-ch1";
++			resets = <&ccu RST_BUS_TCON0>;
++			reset-names = "lcd";
++
++			ports {
++				#address-cells = <1>;
++				#size-cells = <0>;
++
++				tcon0_in: port@0 {
++					reg = <0>;
++
++					tcon0_in_mixer0: endpoint {
++						remote-endpoint = <&mixer0_out_tcon0>;
++					};
++				};
++
++				tcon0_out: port@1 {
++					#address-cells = <1>;
++					#size-cells = <0>;
++					reg = <1>;
++
++					tcon0_out_hdmi: endpoint@1 {
++						reg = <1>;
++						remote-endpoint = <&hdmi_in_tcon0>;
++					};
++				};
++			};
++		};
++
++		mmc0: mmc@1c0f000 {
+ 			/* compatible and clocks are in per SoC .dtsi file */
+ 			reg = <0x01c0f000 0x1000>;
++			pinctrl-names = "default";
++			pinctrl-0 = <&mmc0_pins>;
+ 			resets = <&ccu RST_BUS_MMC0>;
+ 			reset-names = "ahb";
+ 			interrupts = <GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH>;
+@@ -111,9 +215,11 @@
+ 			#size-cells = <0>;
+ 		};
+ 
+-		mmc1: mmc@01c10000 {
++		mmc1: mmc@1c10000 {
+ 			/* compatible and clocks are in per SoC .dtsi file */
+ 			reg = <0x01c10000 0x1000>;
++			pinctrl-names = "default";
++			pinctrl-0 = <&mmc1_pins>;
+ 			resets = <&ccu RST_BUS_MMC1>;
+ 			reset-names = "ahb";
+ 			interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
+@@ -122,7 +228,7 @@
+ 			#size-cells = <0>;
+ 		};
+ 
+-		mmc2: mmc@01c11000 {
++		mmc2: mmc@1c11000 {
+ 			/* compatible and clocks are in per SoC .dtsi file */
+ 			reg = <0x01c11000 0x1000>;
+ 			resets = <&ccu RST_BUS_MMC2>;
+@@ -133,7 +239,7 @@
+ 			#size-cells = <0>;
+ 		};
+ 
+-		usb_otg: usb@01c19000 {
++		usb_otg: usb@1c19000 {
+ 			compatible = "allwinner,sun8i-h3-musb";
+ 			reg = <0x01c19000 0x400>;
+ 			clocks = <&ccu CLK_BUS_OTG>;
+@@ -146,7 +252,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		usbphy: phy@01c19400 {
++		usbphy: phy@1c19400 {
+ 			compatible = "allwinner,sun8i-h3-usb-phy";
+ 			reg = <0x01c19400 0x2c>,
+ 			      <0x01c1a800 0x4>,
+@@ -178,7 +284,7 @@
+ 			#phy-cells = <1>;
+ 		};
+ 
+-		ehci0: usb@01c1a000 {
++		ehci0: usb@1c1a000 {
+ 			compatible = "allwinner,sun8i-h3-ehci", "generic-ehci";
+ 			reg = <0x01c1a000 0x100>;
+ 			interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>;
+@@ -187,7 +293,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		ohci0: usb@01c1a400 {
++		ohci0: usb@1c1a400 {
+ 			compatible = "allwinner,sun8i-h3-ohci", "generic-ohci";
+ 			reg = <0x01c1a400 0x100>;
+ 			interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
+@@ -197,7 +303,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		ehci1: usb@01c1b000 {
++		ehci1: usb@1c1b000 {
+ 			compatible = "allwinner,sun8i-h3-ehci", "generic-ehci";
+ 			reg = <0x01c1b000 0x100>;
+ 			interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+@@ -208,7 +314,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		ohci1: usb@01c1b400 {
++		ohci1: usb@1c1b400 {
+ 			compatible = "allwinner,sun8i-h3-ohci", "generic-ohci";
+ 			reg = <0x01c1b400 0x100>;
+ 			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+@@ -220,7 +326,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		ehci2: usb@01c1c000 {
++		ehci2: usb@1c1c000 {
+ 			compatible = "allwinner,sun8i-h3-ehci", "generic-ehci";
+ 			reg = <0x01c1c000 0x100>;
+ 			interrupts = <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>;
+@@ -231,7 +337,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		ohci2: usb@01c1c400 {
++		ohci2: usb@1c1c400 {
+ 			compatible = "allwinner,sun8i-h3-ohci", "generic-ohci";
+ 			reg = <0x01c1c400 0x100>;
+ 			interrupts = <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>;
+@@ -243,7 +349,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		ehci3: usb@01c1d000 {
++		ehci3: usb@1c1d000 {
+ 			compatible = "allwinner,sun8i-h3-ehci", "generic-ehci";
+ 			reg = <0x01c1d000 0x100>;
+ 			interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
+@@ -254,7 +360,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		ohci3: usb@01c1d400 {
++		ohci3: usb@1c1d400 {
+ 			compatible = "allwinner,sun8i-h3-ohci", "generic-ohci";
+ 			reg = <0x01c1d400 0x100>;
+ 			interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>;
+@@ -266,7 +372,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		ccu: clock@01c20000 {
++		ccu: clock@1c20000 {
+ 			/* compatible is in per SoC .dtsi file */
+ 			reg = <0x01c20000 0x400>;
+ 			clocks = <&osc24M>, <&osc32k>;
+@@ -275,7 +381,7 @@
+ 			#reset-cells = <1>;
+ 		};
+ 
+-		pio: pinctrl@01c20800 {
++		pio: pinctrl@1c20800 {
+ 			/* compatible is in per SoC .dtsi file */
+ 			reg = <0x01c20800 0x400>;
+ 			interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>,
+@@ -310,7 +416,7 @@
+ 				function = "i2c2";
+ 			};
+ 
+-			mmc0_pins_a: mmc0@0 {
++			mmc0_pins_a: mmc0_pins: mmc0 {
+ 				pins = "PF0", "PF1", "PF2", "PF3",
+ 				       "PF4", "PF5";
+ 				function = "mmc0";
+@@ -318,13 +424,13 @@
+ 				bias-pull-up;
+ 			};
+ 
+-			mmc0_cd_pin: mmc0_cd_pin@0 {
++			mmc0_cd_pin: mmc0_cd_pin {
+ 				pins = "PF6";
+ 				function = "gpio_in";
+ 				bias-pull-up;
+ 			};
+ 
+-			mmc1_pins_a: mmc1@0 {
++			mmc1_pins_a: mmc1_pins: mmc1 {
+ 				pins = "PG0", "PG1", "PG2", "PG3",
+ 				       "PG4", "PG5";
+ 				function = "mmc1";
+@@ -342,7 +442,7 @@
+ 				bias-pull-up;
+ 			};
+ 
+-			spdif_tx_pins_a: spdif@0 {
++			spdif_tx_pins_a: spdif {
+ 				pins = "PA17";
+ 				function = "spdif";
+ 			};
+@@ -357,7 +457,7 @@
+ 				function = "spi1";
+ 			};
+ 
+-			uart0_pins_a: uart0@0 {
++			uart0_pins_a: uart0 {
+ 				pins = "PA4", "PA5";
+ 				function = "uart0";
+ 			};
+@@ -381,9 +481,14 @@
+ 				pins = "PA13", "PA14";
+ 				function = "uart3";
+ 			};
++
++			uart3_rts_cts_pins: uart3_rts_cts {
++				pins = "PA15", "PA16";
++				function = "uart3";
++			};
+ 		};
+ 
+-		timer@01c20c00 {
++		timer@1c20c00 {
+ 			compatible = "allwinner,sun4i-a10-timer";
+ 			reg = <0x01c20c00 0xa0>;
+ 			interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>,
+@@ -440,7 +496,7 @@
+ 			};
+ 		};
+ 
+-		spi0: spi@01c68000 {
++		spi0: spi@1c68000 {
+ 			compatible = "allwinner,sun8i-h3-spi";
+ 			reg = <0x01c68000 0x1000>;
+ 			interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>;
+@@ -456,7 +559,7 @@
+ 			#size-cells = <0>;
+ 		};
+ 
+-		spi1: spi@01c69000 {
++		spi1: spi@1c69000 {
+ 			compatible = "allwinner,sun8i-h3-spi";
+ 			reg = <0x01c69000 0x1000>;
+ 			interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>;
+@@ -472,13 +575,13 @@
+ 			#size-cells = <0>;
+ 		};
+ 
+-		wdt0: watchdog@01c20ca0 {
++		wdt0: watchdog@1c20ca0 {
+ 			compatible = "allwinner,sun6i-a31-wdt";
+ 			reg = <0x01c20ca0 0x20>;
+ 			interrupts = <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>;
+ 		};
+ 
+-		spdif: spdif@01c21000 {
++		spdif: spdif@1c21000 {
+ 			#sound-dai-cells = <0>;
+ 			compatible = "allwinner,sun8i-h3-spdif";
+ 			reg = <0x01c21000 0x400>;
+@@ -491,7 +594,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		pwm: pwm@01c21400 {
++		pwm: pwm@1c21400 {
+ 			compatible = "allwinner,sun8i-h3-pwm";
+ 			reg = <0x01c21400 0x8>;
+ 			clocks = <&osc24M>;
+@@ -499,7 +602,33 @@
+ 			status = "disabled";
+ 		};
+ 
+-		codec: codec@01c22c00 {
++		i2s0: i2s@1c22000 {
++			#sound-dai-cells = <0>;
++			compatible = "allwinner,sun8i-h3-i2s";
++			reg = <0x01c22000 0x400>;
++			interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&ccu CLK_BUS_I2S0>, <&ccu CLK_I2S0>;
++			clock-names = "apb", "mod";
++			dmas = <&dma 3>, <&dma 3>;
++			resets = <&ccu RST_BUS_I2S0>;
++			dma-names = "rx", "tx";
++			status = "disabled";
++		};
++
++		i2s1: i2s@1c22400 {
++			#sound-dai-cells = <0>;
++			compatible = "allwinner,sun8i-h3-i2s";
++			reg = <0x01c22400 0x400>;
++			interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&ccu CLK_BUS_I2S1>, <&ccu CLK_I2S1>;
++			clock-names = "apb", "mod";
++			dmas = <&dma 4>, <&dma 4>;
++			resets = <&ccu RST_BUS_I2S1>;
++			dma-names = "rx", "tx";
++			status = "disabled";
++		};
++
++		codec: codec@1c22c00 {
+ 			#sound-dai-cells = <0>;
+ 			compatible = "allwinner,sun8i-h3-codec";
+ 			reg = <0x01c22c00 0x400>;
+@@ -513,7 +542,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		uart0: serial@01c28000 {
++		uart0: serial@1c28000 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x01c28000 0x400>;
+ 			interrupts = <GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH>;
+@@ -526,7 +655,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		uart1: serial@01c28400 {
++		uart1: serial@1c28400 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x01c28400 0x400>;
+ 			interrupts = <GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH>;
+@@ -539,7 +668,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		uart2: serial@01c28800 {
++		uart2: serial@1c28800 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x01c28800 0x400>;
+ 			interrupts = <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+@@ -552,7 +681,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		uart3: serial@01c28c00 {
++		uart3: serial@1c28c00 {
+ 			compatible = "snps,dw-apb-uart";
+ 			reg = <0x01c28c00 0x400>;
+ 			interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+@@ -565,7 +694,7 @@
+ 			status = "disabled";
+ 		};
+ 
+-		i2c0: i2c@01c2ac00 {
++		i2c0: i2c@1c2ac00 {
+ 			compatible = "allwinner,sun6i-a31-i2c";
+ 			reg = <0x01c2ac00 0x400>;
+ 			interrupts = <GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>;
+@@ -578,7 +707,7 @@
+ 			#size-cells = <0>;
+ 		};
+ 
+-		i2c1: i2c@01c2b000 {
++		i2c1: i2c@1c2b000 {
+ 			compatible = "allwinner,sun6i-a31-i2c";
+ 			reg = <0x01c2b000 0x400>;
+ 			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+@@ -591,9 +720,9 @@
+ 			#size-cells = <0>;
+ 		};
+ 
+-		i2c2: i2c@01c2b400 {
++		i2c2: i2c@1c2b400 {
+ 			compatible = "allwinner,sun6i-a31-i2c";
+-			reg = <0x01c2b000 0x400>;
++			reg = <0x01c2b400 0x400>;
+ 			interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>;
+ 			clocks = <&ccu CLK_BUS_I2C2>;
+ 			resets = <&ccu RST_BUS_I2C2>;
+@@ -604,7 +733,7 @@
+ 			#size-cells = <0>;
+ 		};
+ 
+-		gic: interrupt-controller@01c81000 {
++		gic: interrupt-controller@1c81000 {
+ 			compatible = "arm,gic-400";
+ 			reg = <0x01c81000 0x1000>,
+ 			      <0x01c82000 0x2000>,
+@@ -615,7 +744,51 @@
+ 			interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
+ 		};
+ 
+-		rtc: rtc@01f00000 {
++		hdmi: hdmi@1ee0000 {
++			compatible = "allwinner,sun8i-h3-dw-hdmi",
++				     "allwinner,sun8i-a83t-dw-hdmi";
++			reg = <0x01ee0000 0x10000>;
++			reg-io-width = <1>;
++			interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&ccu CLK_BUS_HDMI>, <&ccu CLK_HDMI_DDC>,
++				 <&ccu CLK_HDMI>;
++			clock-names = "iahb", "isfr", "tmds";
++			resets = <&ccu RST_BUS_HDMI1>;
++			reset-names = "ctrl";
++			phys = <&hdmi_phy>;
++			phy-names = "hdmi-phy";
++			status = "disabled";
++
++			ports {
++				#address-cells = <1>;
++				#size-cells = <0>;
++
++				hdmi_in: port@0 {
++					reg = <0>;
++
++					hdmi_in_tcon0: endpoint {
++						remote-endpoint = <&tcon0_out_hdmi>;
++					};
++				};
++
++				hdmi_out: port@1 {
++					reg = <1>;
++				};
++			};
++		};
++
++		hdmi_phy: hdmi-phy@1ef0000 {
++			compatible = "allwinner,sun8i-h3-hdmi-phy";
++			reg = <0x01ef0000 0x10000>;
++			clocks = <&ccu CLK_BUS_HDMI>, <&ccu CLK_HDMI_DDC>,
++				 <&ccu 6>;
++			clock-names = "bus", "mod", "pll-0";
++			resets = <&ccu RST_BUS_HDMI0>;
++			reset-names = "phy";
++			#phy-cells = <0>;
++		};
++
++		rtc: rtc@1f00000 {
+ 			compatible = "allwinner,sun6i-a31-rtc";
+ 			reg = <0x01f00000 0x54>;
+ 			interrupts = <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>,
+@@ -632,12 +805,12 @@
+ 			#reset-cells = <1>;
+ 		};
+ 
+-		codec_analog: codec-analog@01f015c0 {
++		codec_analog: codec-analog@1f015c0 {
+ 			compatible = "allwinner,sun8i-h3-codec-analog";
+ 			reg = <0x01f015c0 0x4>;
+ 		};
+ 
+-		ir: ir@01f02000 {
++		ir: ir@1f02000 {
+ 			compatible = "allwinner,sun5i-a13-ir";
+ 			clocks = <&r_ccu CLK_APB0_IR>, <&r_ccu CLK_IR>;
+ 			clock-names = "apb", "ir";
+@@ -647,7 +820,20 @@
+ 			status = "disabled";
+ 		};
+ 
+-		r_pio: pinctrl@01f02c00 {
++		r_i2c: i2c@1f02400 {
++			compatible = "allwinner,sun6i-a31-i2c";
++			reg = <0x01f02400 0x400>;
++			interrupts = <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>;
++			pinctrl-names = "default";
++			pinctrl-0 = <&r_i2c_pins>;
++			clocks = <&r_ccu CLK_APB0_I2C>;
++			resets = <&r_ccu RST_APB0_I2C>;
++			status = "disabled";
++			#address-cells = <1>;
++			#size-cells = <0>;
++		};
++
++		r_pio: pinctrl@1f02c00 {
+ 			compatible = "allwinner,sun8i-h3-r-pinctrl";
+ 			reg = <0x01f02c00 0x400>;
+ 			interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
+@@ -658,10 +844,15 @@
+ 			interrupt-controller;
+ 			#interrupt-cells = <3>;
+ 
+-			ir_pins_a: ir@0 {
++			ir_pins_a: ir {
+ 				pins = "PL11";
+ 				function = "s_cir_rx";
+ 			};
++
++			r_i2c_pins: r-i2c {
++				pins = "PL0", "PL1";
++				function = "s_i2c";
++			};
+ 		};
+ 	};
+ };
--- a/target/linux/sunxi/patches-4.14/207-add1-thermal_sensor-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/207-add1-thermal_sensor-opi-zero.patch	2021-01-22 00:11:49.808136915 +0200
@@ -0,0 +1,30 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -50,6 +60,7 @@
+ #include <dt-bindings/gpio/gpio.h>
+ #include <dt-bindings/input/input.h>
+ #include <dt-bindings/pinctrl/sun4i-a10.h>
++#include <dt-bindings/thermal/thermal.h>
+ 
+ / {
+ 	model = "Xunlong Orange Pi Zero";
+@@ -107,6 +150,19 @@
+ 		reset-gpios = <&r_pio 0 7 GPIO_ACTIVE_LOW>;
+ 		post-power-on-delay-ms = <200>;
+ 	};
++
++	soc {
++		ths: thermal-sensor@1c25000 {
++			compatible = "allwinner,sun8i-h3-ths";
++			reg = <0x01c25000 0x100>;
++			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
++			clocks = <&ccu CLK_BUS_THS>, <&ccu CLK_THS>;
++			clock-names = "bus", "mod";
++			resets = <&ccu RST_BUS_THS>;
++			#io-channel-cells = <0>;
++			#thermal-sensor-cells = <0>;
++		};
++	};
+ };
+ 
+ &ehci0 {
--- a/target/linux/sunxi/patches-4.14/207-add2-thermal_zone-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/207-add2-thermal_zone-opi-zero.patch	2021-01-22 00:11:49.808136915 +0200
@@ -0,0 +1,44 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -121,7 +150,41 @@
+ 			#thermal-sensor-cells = <0>;
+ 		};
+ 	};
++
++	thermal-zones {
++		cpu_thermal: cpu_thermal {
++			polling-delay-passive = <330>;
++			polling-delay = <1000>;
++			thermal-sensors = <&ths 0>;
++
++			trips {
++				cpu_hot_trip: cpu-warm {
++					temperature = <65000>; /* ~65°C */
++					hysteresis = <2000>;
++					type = "passive";
++				};
++				cpu_very_hot_trip: cpu-very-hot {
++					temperature = <90000>; /* ~90°C */
++					hysteresis = <2000>;
++					type = "critical";
++				};
++			};
++
++			cooling-maps {
++				cpu-warm-limit {
++					trip = <&cpu_hot_trip>;
++					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
++				};
++			};
++		};
++	};
+ };
++
++&cpu0 {
++	cpu-supply = <&reg_vdd_cpux>;
++	cooling-min-level = <0>;
++	cooling-max-level = <15>;
++};
+ 
+ &ehci0 {
+ 	status = "okay";
--- a/target/linux/sunxi/patches-4.14/207-add3-sunxi-ths_linux.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/207-add3-sunxi-ths_linux.patch	2021-01-22 00:11:49.808136915 +0200
@@ -0,0 +1,899 @@
+--- a/Documentation/devicetree/bindings/mfd/sun4i-gpadc.txt	2019-10-01 09:26:13.000000000 +0300
++++ b/Documentation/devicetree/bindings/mfd/sun4i-gpadc.txt	2019-03-12 10:34:30.222802201 +0200
+@@ -4,12 +4,35 @@
+ and sometimes as a touchscreen controller.
+ 
+ Required properties:
+-  - compatible: "allwinner,sun8i-a33-ths",
++  - compatible: must contain one of the following compatibles:
++		- "allwinner,sun8i-a33-ths"
++		- "allwinner,sun8i-h3-ths"
++		- "allwinner,sun8i-a83t-ths"
+   - reg: mmio address range of the chip,
+-  - #thermal-sensor-cells: shall be 0,
++  - #thermal-sensor-cells: shall be 0 or 1,
+   - #io-channel-cells: shall be 0,
+ 
+-Example:
++Required properties for the following compatibles:
++		- "allwinner,sun8i-h3-ths"
++		- "allwinner,sun8i-a83t-ths"
++  - interrupts: the sampling interrupt of the ADC,
++
++Required properties for the following compatibles:
++		- "allwinner,sun8i-h3-ths"
++  - clocks: the bus clock and the input clock of the ADC,
++  - clock-names: should be "bus" and "mod",
++  - resets: the bus reset of the ADC,
++
++Optional properties for the following compatibles:
++		- "allwinner,sun8i-h3-ths"
++  - nvmem-cells: A phandle to the calibration data provided by a nvmem device.
++		If unspecified default values shall be used. The size should
++		be 0x4 or 0x8, depending on the amount of CDATA registers.
++  - nvmem-cell-names: Should be "calibration".
++
++Details see: bindings/nvmem/nvmem.txt
++
++Example for A33:
+ 	ths: ths@01c25000 {
+ 		compatible = "allwinner,sun8i-a33-ths";
+ 		reg = <0x01c25000 0x100>;
+@@ -17,6 +40,27 @@
+ 		#io-channel-cells = <0>;
+ 	};
+ 
++Example for H3:
++	ths: thermal-sensor@1c25000 {
++		compatible = "allwinner,sun8i-h3-ths";
++		reg = <0x01c25000 0x400>;
++		clocks = <&ccu CLK_BUS_THS>, <&ccu CLK_THS>;
++		clock-names = "bus", "mod";
++		resets = <&ccu RST_BUS_THS>;
++		interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
++		#thermal-sensor-cells = <0>;
++		#io-channel-cells = <0>;
++	};
++
++Example for A83T:
++	ths: thermal-sensor@1f04000 {
++		compatible = "allwinner,sun8i-a83t-ths";
++		reg = <0x01f04000 0x100>;
++		interrupts = <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>;
++		#thermal-sensor-cells = <1>;
++		#io-channel-cells = <0>;
++	};
++
+ sun4i, sun5i and sun6i SoCs are also supported via the older binding:
+ 
+ sun4i resistive touchscreen controller
+--- a/drivers/thermal/Kconfig	2019-10-01 09:26:13.000000000 +0300
++++ b/drivers/thermal/Kconfig	2019-03-12 10:34:36.414619070 +0200
+@@ -407,11 +415,29 @@
+ 	  Enable this option if you want to have support for thermal management
+ 	  controller present in Mediatek SoCs
+ 
++config SUN50I_H6_THS
++	tristate "Thermal sensor driver for Allwinner H6"
++	depends on ARCH_SUNXI || COMPILE_TEST
++	depends on HAS_IOMEM
++	depends on NVMEM
++	depends on OF
++	depends on RESET_CONTROLLER
++	help
++	  Enable this option if you want to have support for thermal reporting
++	  on Allwinner H6.
++
+ menu "Broadcom thermal drivers"
+ depends on ARCH_BCM || ARCH_BCM2835 || COMPILE_TEST
+ source "drivers/thermal/broadcom/Kconfig"
+ endmenu
+ 
++config SUN8I_THS
++	tristate "Thermal sensor driver for Allwinner H3"
++	depends on MACH_SUN8I || (ARM64 && ARCH_SUNXI)
++	depends on OF
++	help
++	  Enable this to support thermal reporting on some newer Allwinner SoCs.
++
+ menu "Texas Instruments thermal drivers"
+ depends on ARCH_HAS_BANDGAP || COMPILE_TEST
+ depends on HAS_IOMEM
+--- a/drivers/thermal/Makefile	2019-10-01 09:26:13.000000000 +0300
++++ b/drivers/thermal/Makefile	2019-03-12 10:34:36.414619070 +0200
+@@ -58,6 +58,8 @@
+ obj-$(CONFIG_TEGRA_SOCTHERM)	+= tegra/
+ obj-$(CONFIG_HISI_THERMAL)     += hisi_thermal.o
+ obj-$(CONFIG_MTK_THERMAL)	+= mtk_thermal.o
++obj-$(CONFIG_SUN50I_H6_THS)	+= sun50i_h6_ths.o
+ obj-$(CONFIG_GENERIC_ADC_THERMAL)	+= thermal-generic-adc.o
+ obj-$(CONFIG_ZX2967_THERMAL)	+= zx2967_thermal.o
+ obj-$(CONFIG_UNIPHIER_THERMAL)	+= uniphier_thermal.o
++obj-$(CONFIG_SUN8I_THS)		+= sun8i_ths.o
+--- a/drivers/thermal/sun50i_h6_ths.c	1970-01-01 03:00:00.000000000 +0300
++++ b/drivers/thermal/sun50i_h6_ths.c	2019-03-12 10:34:36.414619070 +0200
+@@ -0,0 +1,365 @@
++/*
++ * Thermal sensor driver for Allwinner H6
++ *
++ * Copyright (C) 2018 Icenowy Zheng
++ *
++ * Based on the work of Ondřej Jirman
++ * Based on the work of Josef Gajdusek <atx@atx.name>
++ *
++ * This software is licensed under the terms of the GNU General Public
++ * License version 2, as published by the Free Software Foundation, and
++ * may be copied, distributed, and modified under those terms.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ */
++
++#include <linux/clk.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/nvmem-consumer.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/reset.h>
++#include <linux/slab.h>
++#include <linux/thermal.h>
++#include <linux/printk.h>
++
++#define THS_H6_MAX_SENSOR_NUM	4
++
++#define THS_H6_CTRL0		0x00
++#define THS_H6_CTRL2		0x04
++#define THS_H6_PER		0x08
++#define THS_H6_DATA_INT_CTRL	0x10
++#define THS_H6_DATA_INT_STAT	0x20
++#define THS_H6_FILTER		0x30
++#define THS_H6_CDATA(n)		(0xa0 + 4 * (n))
++#define THS_H6_DATA(n)		(0xc0 + 4 * (n))
++
++#define THS_H6_CTRL0_SENSOR_ACQ0(x)	((x) << 16)
++#define THS_H6_CTRL2_SENSE_EN(n)	BIT(0 + (n))
++#define THS_H6_PER_THERMAL_PER(x)	((x) << 12)
++#define THS_H6_INT_CTRL_DATA_IRQ_EN(n)	BIT(0 + (n))
++#define THS_H6_STAT_DATA_IRQ_STS(n)	BIT(0 + (n))
++#define THS_H6_FILTER_TYPE(x)		((x) << 0)
++#define THS_H6_FILTER_EN		BIT(2)
++
++#define THS_H6_CLK_IN		240000000 /* Hz */
++#define THS_H6_DATA_PERIOD	10 /* ms */
++
++#define THS_H6_FILTER_TYPE_VALUE	2 /* average over 2^(n+1) samples */
++#define THS_H6_FILTER_DIV		(1 << (THS_H6_FILTER_TYPE_VALUE + 1))
++#define THS_H6_INT_CTRL_THERMAL_PER_VALUE \
++	(THS_H6_DATA_PERIOD * (THS_H6_CLK_IN / 1000) / THS_H6_FILTER_DIV / 4096 - 1)
++#define THS_H6_CTRL0_SENSOR_ACQ0_VALUE	0x1df /* 20us */
++#define THS_H6_CTRL0_UNK		0x0000002f
++
++#define THS_H6_CAL_FT_TEMP_MASK		0x0fff
++#define THS_H6_CAL_FT_TEMP_DEVIATION_EN	0x3000
++#define THS_H6_CAL_DEFAULT		0x800
++#define THS_H6_CAL_VAL_MASK		0xfff
++
++struct sun50i_h6_ths_data;
++
++struct sun50i_h6_ths_sensor {
++	struct sun50i_h6_ths_data *data;
++	int id;
++	struct thermal_zone_device *tzd;
++	u32 val;
++};
++
++struct sun50i_h6_ths_cfg {
++	int sensor_num;
++	int (*calc_temp)(u32 val);
++};
++
++struct sun50i_h6_ths_data {
++	struct reset_control *reset;
++	struct clk *busclk;
++	void __iomem *regs;
++	const struct sun50i_h6_ths_cfg *cfg;
++	struct nvmem_cell *calcell;
++	struct sun50i_h6_ths_sensor sensors[THS_H6_MAX_SENSOR_NUM];
++};
++
++static int sun50i_h6_ths_calc_temp(u32 val)
++{
++	return (187744 - (int)((val * 1000000) / 14882));
++}
++
++static u16 sun50i_h6_ths_recalc_reg(u32 temp)
++{
++	return (u16)(2794 - temp * 14882 / 1000000);
++}
++
++static int sun50i_h6_ths_get_temp(void *_data, int *out)
++{
++	struct sun50i_h6_ths_sensor *sensor = _data;
++
++	if (sensor->val == 0)
++		return -EBUSY;
++
++	/* Formula and parameters from the Allwinner 3.4 kernel */
++	*out = sensor->data->cfg->calc_temp(sensor->val);
++	return 0;
++}
++
++static irqreturn_t sun50i_h6_ths_irq_thread(int irq, void *_data)
++{
++	struct sun50i_h6_ths_data *data = _data;
++	int i;
++
++	for (i = 0; i < data->cfg->sensor_num; i++) {
++		if (!(readl(data->regs + THS_H6_DATA_INT_STAT) &
++		      THS_H6_STAT_DATA_IRQ_STS(i)))
++			continue;
++
++		writel(THS_H6_STAT_DATA_IRQ_STS(i),
++		       data->regs + THS_H6_DATA_INT_STAT);
++
++		data->sensors[i].val = readl(data->regs + THS_H6_DATA(i));
++		if (data->sensors[i].val)
++			thermal_zone_device_update(data->sensors[i].tzd,
++						   THERMAL_EVENT_TEMP_SAMPLE);
++	}
++
++	return IRQ_HANDLED;
++}
++
++static void sun50i_h6_ths_init(struct sun50i_h6_ths_data *data)
++{
++	u32 val;
++	int i;
++
++	writel(THS_H6_CTRL0_SENSOR_ACQ0(THS_H6_CTRL0_SENSOR_ACQ0_VALUE) |
++	       THS_H6_CTRL0_UNK, data->regs + THS_H6_CTRL0);
++	writel(THS_H6_FILTER_EN | THS_H6_FILTER_TYPE(THS_H6_FILTER_TYPE_VALUE),
++	       data->regs + THS_H6_FILTER);
++
++	val = 0;
++	for (i = 0; i < data->cfg->sensor_num; i++)
++		val |= THS_H6_CTRL2_SENSE_EN(i);
++	writel(val, data->regs + THS_H6_CTRL2);
++
++	val = THS_H6_PER_THERMAL_PER(THS_H6_INT_CTRL_THERMAL_PER_VALUE);
++	writel(val, data->regs + THS_H6_PER);
++
++	val = 0;
++	for (i = 0; i < data->cfg->sensor_num; i++)
++		val |= THS_H6_INT_CTRL_DATA_IRQ_EN(i);
++	writel(val, data->regs + THS_H6_DATA_INT_CTRL);
++}
++
++static const struct thermal_zone_of_device_ops sun50i_h6_ths_thermal_ops = {
++	.get_temp = sun50i_h6_ths_get_temp,
++};
++
++static int sun50i_h6_ths_calibrate(struct sun50i_h6_ths_data *data)
++{
++	u16 *caldata;
++	size_t callen;
++	int i;
++	int ft_temp;
++	s16 ft_temp_orig_reg, diff, cal_val;
++	u32 reg_val;
++
++	caldata = nvmem_cell_read(data->calcell, &callen);
++	if (IS_ERR(caldata))
++		return PTR_ERR(caldata);
++
++	if (callen < 2 + 2 * data->cfg->sensor_num)
++		return -EINVAL;
++
++	if (!caldata[0])
++		return -EINVAL;
++
++	/*
++	 * The calbration data on H6 is stored as temperature-value
++	 * pair when being filled at factory test stage.
++	 * The unit of stored FT temperature is 0.1 degreee celusis.
++	 */
++	ft_temp = (caldata[0] & THS_H6_CAL_FT_TEMP_MASK) * 100;
++	ft_temp_orig_reg = sun50i_h6_ths_recalc_reg(ft_temp);
++
++	for (i = 0; i < data->cfg->sensor_num; i++)
++	{
++		diff = (ft_temp_orig_reg - (s16)caldata[1 + i]);
++		cal_val = THS_H6_CAL_DEFAULT - diff;
++
++		if (cal_val & ~THS_H6_CAL_VAL_MASK) {
++			pr_warn("Faulty thermal sensor %d calibration value, beyond the valid range.\n", i);
++			continue;
++		}
++
++		if (i % 2) {
++			reg_val = readl(data->regs + THS_H6_CDATA(i / 2));
++			reg_val &= 0xffff;
++			reg_val |= cal_val << 16;
++			writel(reg_val, data->regs + THS_H6_CDATA(i / 2));
++		} else {
++			writel(cal_val, data->regs + THS_H6_CDATA(i / 2));
++		}
++	}
++
++	kfree(caldata);
++	return 0;
++}
++
++static int sun50i_h6_ths_probe(struct platform_device *pdev)
++{
++	struct sun50i_h6_ths_data *data;
++	struct resource *res;
++	int ret, irq, i;
++
++	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
++
++	data->cfg = of_device_get_match_data(&pdev->dev);
++	if (!data->cfg)
++		return -EINVAL;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res) {
++		dev_err(&pdev->dev, "no memory resources defined\n");
++		return -EINVAL;
++	}
++
++	data->regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(data->regs)) {
++		ret = PTR_ERR(data->regs);
++		dev_err(&pdev->dev, "failed to ioremap THS registers: %d\n", ret);
++		return ret;
++	}
++
++	irq = platform_get_irq(pdev, 0);
++	if (irq < 0) {
++		dev_err(&pdev->dev, "failed to get IRQ: %d\n", irq);
++		return irq;
++	}
++
++	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
++					sun50i_h6_ths_irq_thread, IRQF_ONESHOT,
++					dev_name(&pdev->dev), data);
++	if (ret)
++		return ret;
++
++	data->busclk = devm_clk_get(&pdev->dev, "bus");
++	if (IS_ERR(data->busclk)) {
++		ret = PTR_ERR(data->busclk);
++		dev_err(&pdev->dev, "failed to get ahb clk: %d\n", ret);
++		return ret;
++	}
++
++	data->reset = devm_reset_control_get(&pdev->dev, NULL);
++	if (IS_ERR(data->reset)) {
++		ret = PTR_ERR(data->reset);
++		dev_err(&pdev->dev, "failed to get reset: %d\n", ret);
++		return ret;
++	}
++
++	ret = reset_control_deassert(data->reset);
++	if (ret) {
++		dev_err(&pdev->dev, "reset deassert failed: %d\n", ret);
++		return ret;
++	}
++
++	ret = clk_prepare_enable(data->busclk);
++	if (ret) {
++		dev_err(&pdev->dev, "failed to enable bus clk: %d\n", ret);
++		goto err_assert_reset;
++	}
++
++	data->calcell = devm_nvmem_cell_get(&pdev->dev, "calibration");
++	if (IS_ERR(data->calcell)) {
++		if (PTR_ERR(data->calcell) == -EPROBE_DEFER) {
++			ret = PTR_ERR(data->calcell);
++			goto err_disable_bus;
++		}
++		/*
++		* Even if the external calibration data stored in eFUSE is
++		* not accessible, the THS hardware can still work, although
++		* the data won't be so accurate.
++		* The default value of calibration register is 0x800 for
++		* every sensor, and the calibration value is usually 0x7xx
++		* or 0x8xx, so they won't be away from the default value
++		* for a lot.
++		* So here we do not return if the calibartion data is not
++		* available, except the probe needs deferring.
++		*/
++	} else {
++		ret = sun50i_h6_ths_calibrate(data);
++		if (ret) {
++			/* Revert calibrating */
++			for (i = 0; i < data->cfg->sensor_num; i += 2) {
++				writew(THS_H6_CAL_DEFAULT,
++				       data->regs + THS_H6_CDATA(i / 2));
++			}
++		}
++	}
++
++	for (i = 0; i < data->cfg->sensor_num; i++) {
++		data->sensors[i].data = data;
++		data->sensors[i].id = i;
++		data->sensors[i].tzd =
++			devm_thermal_zone_of_sensor_register(&pdev->dev,
++				i, &data->sensors[i], &sun50i_h6_ths_thermal_ops);
++		if (IS_ERR(data->sensors[i].tzd)) {
++			ret = PTR_ERR(data->sensors[i].tzd);
++			dev_err(&pdev->dev,
++				"failed to register thermal zone %d: %d\n",
++				i, ret);
++			goto err_disable_bus;
++		}
++	}
++
++	sun50i_h6_ths_init(data);
++
++	platform_set_drvdata(pdev, data);
++	return 0;
++
++err_disable_bus:
++	clk_disable_unprepare(data->busclk);
++err_assert_reset:
++	reset_control_assert(data->reset);
++	return ret;
++}
++
++static int sun50i_h6_ths_remove(struct platform_device *pdev)
++{
++	struct sun50i_h6_ths_data *data = platform_get_drvdata(pdev);
++
++	reset_control_assert(data->reset);
++	clk_disable_unprepare(data->busclk);
++	return 0;
++}
++
++static const struct sun50i_h6_ths_cfg sun50i_h6_ths_cfg = {
++	.sensor_num = 2,
++	.calc_temp = sun50i_h6_ths_calc_temp,
++};
++
++static const struct of_device_id sun50i_h6_ths_id_table[] = {
++	{ .compatible = "allwinner,sun50i-h6-ths", .data = &sun50i_h6_ths_cfg },
++	{ /* sentinel */ },
++};
++MODULE_DEVICE_TABLE(of, sun50i_h6_ths_id_table);
++
++static struct platform_driver sun50i_h6_ths_driver = {
++	.probe = sun50i_h6_ths_probe,
++	.remove = sun50i_h6_ths_remove,
++	.driver = {
++		.name = "sun50i_h6_ths",
++		.of_match_table = sun50i_h6_ths_id_table,
++	},
++};
++
++module_platform_driver(sun50i_h6_ths_driver);
++
++MODULE_AUTHOR("Icenowy Zheng <icenowy@aosc.io>");
++MODULE_DESCRIPTION("Thermal sensor driver for Allwinner H6");
++MODULE_LICENSE("GPL v2");
+--- a/drivers/thermal/sun8i_ths.c	1970-01-01 03:00:00.000000000 +0300
++++ b/drivers/thermal/sun8i_ths.c	2019-03-12 00:33:20.246514437 +0200
+@@ -0,0 +1,416 @@
++/*
++ * Thermal sensor driver for Allwinner SUN8I SoC
++ *
++ * Copyright (C) 2016 Ondřej Jirman
++ * Based on the work of Josef Gajdusek <atx@atx.name>
++ *
++ * This software is licensed under the terms of the GNU General Public
++ * License version 2, as published by the Free Software Foundation, and
++ * may be copied, distributed, and modified under those terms.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
++ * GNU General Public License for more details.
++ *
++ */
++
++#include <linux/clk.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/module.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/reset.h>
++#include <linux/slab.h>
++#include <linux/thermal.h>
++#include <linux/printk.h>
++
++#define THS_SUN8I_CTRL0		0x00
++#define THS_SUN8I_CTRL2		0x40
++#define THS_SUN8I_INT_CTRL	0x44
++#define THS_SUN8I_STAT		0x48
++#define THS_SUN8I_FILTER	0x70
++#define THS_SUN8I_CDATA01	0x74
++#define THS_SUN8I_CDATA2	0x78
++#define THS_SUN8I_DATA0		0x80
++#define THS_SUN8I_DATA1		0x84
++#define THS_SUN8I_DATA2		0x88
++
++#define THS_SUN8I_CTRL0_SENSOR_ACQ0(x)		(x)
++#define THS_SUN8I_CTRL2_SENSE_EN0		BIT(0)
++#define THS_SUN8I_CTRL2_SENSE_EN1		BIT(1)
++#define THS_SUN8I_CTRL2_SENSE_EN2		BIT(2)
++#define THS_SUN8I_CTRL2_SENSOR_ACQ1(x)		((x) << 16)
++#define THS_SUN8I_INT_CTRL_DATA0_IRQ_EN		BIT(8)
++#define THS_SUN8I_INT_CTRL_DATA1_IRQ_EN		BIT(9)
++#define THS_SUN8I_INT_CTRL_DATA2_IRQ_EN		BIT(10)
++#define THS_SUN8I_INT_CTRL_THERMAL_PER(x)	((x) << 12)
++#define THS_SUN8I_STAT_DATA0_IRQ_STS		BIT(8)
++#define THS_SUN8I_STAT_DATA1_IRQ_STS		BIT(9)
++#define THS_SUN8I_STAT_DATA2_IRQ_STS		BIT(10)
++#define THS_SUN8I_STAT_CLEAR			0x777
++#define THS_SUN8I_FILTER_TYPE(x)		((x) << 0)
++#define THS_SUN8I_FILTER_EN			BIT(2)
++
++#define THS_SUN8I_CLK_IN		40000000 /* Hz */
++#define THS_SUN8I_DATA_PERIOD		330 /* ms */
++#define THS_SUN8I_FILTER_TYPE_VALUE	2 /* average over 2^(n+1) samples */
++
++//XXX: this formula doesn't work for A83T very well
++//XXX: A83T is getting slower readings out of this (1s interval?)
++//perhaps configure this in sun8i_ths_desc
++#define THS_SUN8I_FILTER_DIV		(1 << (THS_SUN8I_FILTER_TYPE_VALUE + 1))
++#define THS_SUN8I_INT_CTRL_THERMAL_PER_VALUE \
++	(THS_SUN8I_DATA_PERIOD * (THS_SUN8I_CLK_IN / 1000) / \
++	 THS_SUN8I_FILTER_DIV / 4096 - 1)
++
++#define THS_SUN8I_CTRL0_SENSOR_ACQ0_VALUE	0x3f /* 16us */
++#define THS_SUN8I_CTRL2_SENSOR_ACQ1_VALUE	0x3f
++
++#define SUN8I_THS_MAX_TZDS 3
++
++struct sun8i_ths_sensor_desc {
++	u32 data_int_en;
++	u32 data_int_flag;
++	u32 data_offset;
++	u32 sense_en;
++};
++
++struct sun8i_ths_desc {
++	int num_sensors;
++	struct sun8i_ths_sensor_desc *sensors;
++	int (*calc_temp)(u32 reg_val);
++	bool has_cal1;
++};
++
++struct sun8i_ths_tzd {
++	struct sun8i_ths_data *data;
++	struct thermal_zone_device *tzd;
++	u32 temp;
++};
++
++struct sun8i_ths_data {
++	struct device *dev;
++	struct reset_control *reset;
++	struct clk *clk;
++	struct clk *busclk;
++	void __iomem *regs;
++	void __iomem *cal_regs;
++	struct sun8i_ths_desc *desc;
++	struct sun8i_ths_tzd tzds[SUN8I_THS_MAX_TZDS];
++};
++
++static int sun8i_ths_calc_temp_h3(u32 reg_val)
++{
++	uint64_t temp = (uint64_t)reg_val * 1000000ll;
++
++        do_div(temp, 8253);
++
++	return 217000 - (int)temp;
++}
++
++static int sun8i_ths_calc_temp_a83t(u32 reg_val)
++{
++	uint64_t temp = (uint64_t)reg_val * 1000000ll;
++
++        do_div(temp, 14186);
++
++	return 192000 - (int)temp;
++}
++
++static int sun8i_ths_get_temp(void *_data, int *out)
++{
++	struct sun8i_ths_tzd *tzd = _data;
++	struct sun8i_ths_data *data = tzd->data;
++
++	if (tzd->temp == 0)
++		return -EBUSY;
++
++	*out = data->desc->calc_temp(tzd->temp);
++	return 0;
++}
++
++static irqreturn_t sun8i_ths_irq_thread(int irq, void *_data)
++{
++	struct sun8i_ths_data *data = _data;
++	struct sun8i_ths_tzd *tzd;
++	struct sun8i_ths_sensor_desc *zdesc;
++	int i;
++	u32 status;
++
++	status = readl(data->regs + THS_SUN8I_STAT);
++	writel(THS_SUN8I_STAT_CLEAR, data->regs + THS_SUN8I_STAT);
++
++	for (i = 0; i < data->desc->num_sensors; i++) {
++		tzd = &data->tzds[i];
++		zdesc = &data->desc->sensors[i];
++
++		if (status & zdesc->data_int_flag) {
++			tzd->temp = readl(data->regs + zdesc->data_offset);
++			if (tzd->temp)
++				thermal_zone_device_update(tzd->tzd,
++							   THERMAL_EVENT_TEMP_SAMPLE);
++		}
++	}
++
++	return IRQ_HANDLED;
++}
++
++static void sun8i_ths_init(struct sun8i_ths_data *data)
++{
++	int i;
++	u32 int_ctrl = 0;
++	u32 ctrl2 = 0;
++
++	writel(THS_SUN8I_CTRL0_SENSOR_ACQ0(THS_SUN8I_CTRL0_SENSOR_ACQ0_VALUE),
++		data->regs + THS_SUN8I_CTRL0);
++	writel(THS_SUN8I_FILTER_EN | THS_SUN8I_FILTER_TYPE(THS_SUN8I_FILTER_TYPE_VALUE),
++		data->regs + THS_SUN8I_FILTER);
++
++	ctrl2 |= THS_SUN8I_CTRL2_SENSOR_ACQ1(THS_SUN8I_CTRL2_SENSOR_ACQ1_VALUE);
++	int_ctrl |= THS_SUN8I_INT_CTRL_THERMAL_PER(THS_SUN8I_INT_CTRL_THERMAL_PER_VALUE);
++
++	for (i = 0; i < data->desc->num_sensors; i++) {
++		ctrl2 |= data->desc->sensors[i].sense_en;
++		int_ctrl |= data->desc->sensors[i].data_int_en;
++	}
++
++	if (data->cal_regs) {
++		u32 cal0, cal1;
++
++		cal0 = readl(data->cal_regs);
++		if (cal0)
++			writel(cal0, data->regs + THS_SUN8I_CDATA01);
++
++		if (data->desc->has_cal1) {
++			cal1 = readl(data->cal_regs + 4);
++			if (cal1)
++				writel(cal1, data->regs + THS_SUN8I_CDATA2);
++		}
++	}
++
++	writel(ctrl2, data->regs + THS_SUN8I_CTRL2);
++
++	/* enable interrupts */
++	writel(int_ctrl, data->regs + THS_SUN8I_INT_CTRL);
++}
++
++static const struct thermal_zone_of_device_ops sun8i_ths_thermal_ops = {
++	.get_temp = sun8i_ths_get_temp,
++};
++
++static int sun8i_ths_probe(struct platform_device *pdev)
++{
++	struct sun8i_ths_data *data;
++	struct device *dev = &pdev->dev;
++	struct resource *res;
++	int ret, irq, i;
++
++	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
++
++	data->desc = (struct sun8i_ths_desc *)of_device_get_match_data(dev);
++	if (data->desc == NULL)
++		return -EINVAL;
++
++	data->dev = dev;
++	platform_set_drvdata(pdev, data);
++
++	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ths");
++        if (!res) {
++                dev_err(dev, "no memory resources defined\n");
++                return -EINVAL;
++        }
++
++	data->regs = devm_ioremap_resource(dev, res);
++	if (IS_ERR(data->regs)) {
++		ret = PTR_ERR(data->regs);
++		dev_err(dev, "failed to ioremap THS registers: %d\n", ret);
++		return ret;
++	}
++
++	/*XXX: use SRAM device in the future, instead of direct access to regs */
++	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "calibration");
++        if (res) {
++		data->cal_regs = devm_ioremap_resource(dev, res);
++		if (IS_ERR(data->cal_regs)) {
++			ret = PTR_ERR(data->cal_regs);
++			dev_err(dev, "failed to ioremap calibration SRAM: %d\n", ret);
++			return ret;
++		}
++        }
++
++	irq = platform_get_irq(pdev, 0);
++	if (irq < 0) {
++		dev_err(dev, "failed to get IRQ: %d\n", irq);
++		return irq;
++	}
++
++	ret = devm_request_threaded_irq(dev, irq, NULL,
++					sun8i_ths_irq_thread, IRQF_ONESHOT,
++					dev_name(dev), data);
++	if (ret)
++		return ret;
++
++	data->busclk = devm_clk_get(dev, "ahb");
++	if (IS_ERR(data->busclk)) {
++		ret = PTR_ERR(data->busclk);
++		if (ret != -ENOENT) {
++			dev_err(dev, "failed to get ahb clk: %d\n", ret);
++			return ret;
++		}
++
++		data->busclk = NULL;
++	}
++
++	data->clk = devm_clk_get(dev, "ths");
++	if (IS_ERR(data->clk)) {
++		ret = PTR_ERR(data->clk);
++		if (ret != -ENOENT) {
++			dev_err(dev, "failed to get ths clk: %d\n", ret);
++			return ret;
++		}
++
++		data->clk = NULL;
++	}
++
++	data->reset = devm_reset_control_get_optional(dev, "ahb");
++	if (IS_ERR(data->reset)) {
++		ret = PTR_ERR(data->reset);
++		dev_err(dev, "failed to get reset: %d\n", ret);
++		return ret;
++	}
++
++	ret = reset_control_deassert(data->reset);
++	if (ret) {
++		dev_err(dev, "reset deassert failed: %d\n", ret);
++		return ret;
++	}
++
++	if (data->busclk) {
++		ret = clk_prepare_enable(data->busclk);
++		if (ret) {
++			dev_err(dev, "failed to enable bus clk: %d\n", ret);
++			goto err_assert_reset;
++		}
++	}
++
++	if (data->clk) {
++		ret = clk_prepare_enable(data->clk);
++		if (ret) {
++			dev_err(dev, "failed to enable ths clk: %d\n", ret);
++			goto err_disable_bus;
++		}
++
++		ret = clk_set_rate(data->clk, THS_SUN8I_CLK_IN);
++		if (ret)
++			goto err_disable_ths;
++	}
++
++	for (i = 0; i < data->desc->num_sensors; i++) {
++		data->tzds[i].data = data;
++		data->tzds[i].tzd =
++			devm_thermal_zone_of_sensor_register(dev, i,
++							     &data->tzds[i],
++							     &sun8i_ths_thermal_ops);
++		if (IS_ERR(data->tzds[i].tzd)) {
++			ret = PTR_ERR(data->tzds[i].tzd);
++			dev_err(dev,
++				"failed to register thermal zone: %d\n", ret);
++			goto err_disable_ths;
++		}
++	}
++
++	sun8i_ths_init(data);
++	return 0;
++
++err_disable_ths:
++	if (data->clk)
++		clk_disable_unprepare(data->clk);
++err_disable_bus:
++	if (data->busclk)
++		clk_disable_unprepare(data->busclk);
++err_assert_reset:
++	reset_control_assert(data->reset);
++	return ret;
++}
++
++static int sun8i_ths_remove(struct platform_device *pdev)
++{
++	struct sun8i_ths_data *data = platform_get_drvdata(pdev);
++
++	reset_control_assert(data->reset);
++	if (data->clk)
++		clk_disable_unprepare(data->clk);
++	if (data->busclk)
++		clk_disable_unprepare(data->busclk);
++	return 0;
++}
++
++struct sun8i_ths_sensor_desc sun8i_ths_h3_sensors[] = {
++	{
++		.data_int_en = THS_SUN8I_INT_CTRL_DATA0_IRQ_EN,
++		.data_int_flag = THS_SUN8I_STAT_DATA0_IRQ_STS,
++		.data_offset = THS_SUN8I_DATA0,
++		.sense_en = THS_SUN8I_CTRL2_SENSE_EN0,
++	},
++};
++
++struct sun8i_ths_sensor_desc sun8i_ths_a83t_sensors[] = {
++	{
++		.data_int_en = THS_SUN8I_INT_CTRL_DATA0_IRQ_EN,
++		.data_int_flag = THS_SUN8I_STAT_DATA0_IRQ_STS,
++		.data_offset = THS_SUN8I_DATA0,
++		.sense_en = THS_SUN8I_CTRL2_SENSE_EN0,
++	},
++	{
++		.data_int_en = THS_SUN8I_INT_CTRL_DATA1_IRQ_EN,
++		.data_int_flag = THS_SUN8I_STAT_DATA1_IRQ_STS,
++		.data_offset = THS_SUN8I_DATA1,
++		.sense_en = THS_SUN8I_CTRL2_SENSE_EN1,
++	},
++	{
++		.data_int_en = THS_SUN8I_INT_CTRL_DATA2_IRQ_EN,
++		.data_int_flag = THS_SUN8I_STAT_DATA2_IRQ_STS,
++		.data_offset = THS_SUN8I_DATA2,
++		.sense_en = THS_SUN8I_CTRL2_SENSE_EN2,
++	},
++};
++
++static const struct sun8i_ths_desc sun8i_ths_h3_desc = {
++	.num_sensors = ARRAY_SIZE(sun8i_ths_h3_sensors),
++	.sensors = sun8i_ths_h3_sensors,
++	.calc_temp = sun8i_ths_calc_temp_h3,
++	.has_cal1 = false,
++};
++
++static const struct sun8i_ths_desc sun8i_ths_a83t_desc = {
++	.num_sensors = ARRAY_SIZE(sun8i_ths_a83t_sensors),
++	.sensors = sun8i_ths_a83t_sensors,
++	.calc_temp = sun8i_ths_calc_temp_a83t,
++	.has_cal1 = true,
++};
++
++static const struct of_device_id sun8i_ths_id_table[] = {
++	{ .compatible = "allwinner,sun8i-h3-ths", .data = &sun8i_ths_h3_desc },
++	{ .compatible = "allwinner,sun8i-a83t-ths", .data = &sun8i_ths_a83t_desc },
++	{ /* sentinel */ },
++};
++MODULE_DEVICE_TABLE(of, sun8i_ths_id_table);
++
++static struct platform_driver sun8i_ths_driver = {
++	.probe = sun8i_ths_probe,
++	.remove = sun8i_ths_remove,
++	.driver = {
++		.name = "sun8i_ths",
++		.of_match_table = sun8i_ths_id_table,
++	},
++};
++
++module_platform_driver(sun8i_ths_driver);
++
++MODULE_AUTHOR("Ondřej Jirman <megous@megous.com>");
++MODULE_DESCRIPTION("Thermal sensor driver for Allwinner SUN8I SoCs");
++MODULE_LICENSE("GPL v2");
--- a/target/linux/sunxi/patches-4.14/207-add4-sunxi-iio_gpadc_linux.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/207-add4-sunxi-iio_gpadc_linux.patch	2021-01-22 00:11:49.812136809 +0200
@@ -0,0 +1,90 @@
+--- a/drivers/iio/adc/sun4i-gpadc-iio.c	2020-01-29 16:02:39.000000000 +0200
++++ b/drivers/iio/adc/sun4i-gpadc-iio.c	2020-02-01 11:37:12.000000000 +0200
+@@ -352,7 +352,6 @@
+ 
+ static const struct iio_info sun4i_gpadc_iio_info = {
+ 	.read_raw = sun4i_gpadc_read_raw,
+-	.driver_module = THIS_MODULE,
+ };
+ 
+ static irqreturn_t sun4i_gpadc_temp_data_irq_handler(int irq, void *dev_id)
+@@ -502,17 +501,15 @@
+ 				struct iio_dev *indio_dev)
+ {
+ 	struct sun4i_gpadc_iio *info = iio_priv(indio_dev);
+-	const struct of_device_id *of_dev;
+ 	struct resource *mem;
+ 	void __iomem *base;
+ 	int ret;
+ 
+-	of_dev = of_match_device(sun4i_gpadc_of_id, &pdev->dev);
+-	if (!of_dev)
++	info->data = of_device_get_match_data(&pdev->dev);
++	if (!info->data)
+ 		return -ENODEV;
+ 
+ 	info->no_irq = true;
+-	info->data = (struct gpadc_data *)of_dev->data;
+ 	indio_dev->num_channels = ARRAY_SIZE(sun8i_a33_gpadc_channels);
+ 	indio_dev->channels = sun8i_a33_gpadc_channels;
+ 
+@@ -529,17 +526,10 @@
+ 		return ret;
+ 	}
+ 
+-	if (!IS_ENABLED(CONFIG_THERMAL_OF))
+-		return 0;
++	if (IS_ENABLED(CONFIG_THERMAL_OF))
++		info->sensor_device = &pdev->dev;
+ 
+-	info->sensor_device = &pdev->dev;
+-	info->tzd = thermal_zone_of_sensor_register(info->sensor_device, 0,
+-						    info, &sun4i_ts_tz_ops);
+-	if (IS_ERR(info->tzd))
+-		dev_err(&pdev->dev, "could not register thermal sensor: %ld\n",
+-			PTR_ERR(info->tzd));
+-
+-	return PTR_ERR_OR_ZERO(info->tzd);
++	return 0;
+ }
+ 
+ static int sun4i_gpadc_probe_mfd(struct platform_device *pdev,
+@@ -586,15 +576,6 @@
+ 		 * return the temperature.
+ 		 */
+ 		info->sensor_device = pdev->dev.parent;
+-		info->tzd = thermal_zone_of_sensor_register(info->sensor_device,
+-							    0, info,
+-							    &sun4i_ts_tz_ops);
+-		if (IS_ERR(info->tzd)) {
+-			dev_err(&pdev->dev,
+-				"could not register thermal sensor: %ld\n",
+-				PTR_ERR(info->tzd));
+-			return PTR_ERR(info->tzd);
+-		}
+ 	} else {
+ 		indio_dev->num_channels =
+ 			ARRAY_SIZE(sun4i_gpadc_channels_no_temp);
+@@ -664,6 +645,22 @@
+ 	pm_runtime_set_suspended(&pdev->dev);
+ 	pm_runtime_enable(&pdev->dev);
+ 
++	if (IS_ENABLED(CONFIG_THERMAL_OF)) {
++		info->tzd = thermal_zone_of_sensor_register(info->sensor_device,
++							    0, info,
++							    &sun4i_ts_tz_ops);
++		/*
++		 * Do not fail driver probing when failing to register in
++		 * thermal because no thermal DT node is found.
++		 */
++		if (IS_ERR(info->tzd) && PTR_ERR(info->tzd) != -ENODEV) {
++			dev_err(&pdev->dev,
++				"could not register thermal sensor: %ld\n",
++				PTR_ERR(info->tzd));
++			return PTR_ERR(info->tzd);
++		}
++	}
++
+ 	ret = devm_iio_device_register(&pdev->dev, indio_dev);
+ 	if (ret < 0) {
+ 		dev_err(&pdev->dev, "could not register the device\n");
--- a/target/linux/sunxi/patches-4.14/207-add5-sunxi-iio_gpadc_linux.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/207-add5-sunxi-iio_gpadc_linux.patch	2021-01-22 00:11:49.812136809 +0200
@@ -0,0 +1,824 @@
+--- a/drivers/iio/adc/sun4i-gpadc-iio.c	2019-10-01 09:26:13.000000000 +0300
++++ b/drivers/iio/adc/sun4i-gpadc-iio.c	2019-03-12 10:34:30.642789776 +0200
+@@ -22,15 +22,18 @@
+  * shutdown for not being used.
+  */
+ 
++#include <linux/clk.h>
+ #include <linux/completion.h>
+ #include <linux/interrupt.h>
+ #include <linux/io.h>
+ #include <linux/module.h>
++#include <linux/nvmem-consumer.h>
+ #include <linux/of.h>
+ #include <linux/of_device.h>
+ #include <linux/platform_device.h>
+ #include <linux/pm_runtime.h>
+ #include <linux/regmap.h>
++#include <linux/reset.h>
+ #include <linux/thermal.h>
+ #include <linux/delay.h>
+ 
+@@ -49,6 +52,18 @@
+ 	return SUN6I_GPADC_CTRL1_ADC_CHAN_SELECT(chan);
+ }
+ 
++struct sun4i_gpadc_iio;
++
++/*
++ * Prototypes for these functions, which enable these functions to be
++ * referenced in gpadc_data structures.
++ */
++static int sun4i_gpadc_sample_start(struct sun4i_gpadc_iio *info);
++static int sun4i_gpadc_sample_end(struct sun4i_gpadc_iio *info);
++
++static int sunxi_ths_sample_start(struct sun4i_gpadc_iio *info);
++static int sunxi_ths_sample_end(struct sun4i_gpadc_iio *info);
++
+ struct gpadc_data {
+ 	int		temp_offset;
+ 	int		temp_scale;
+@@ -56,6 +71,21 @@
+ 	unsigned int	tp_adc_select;
+ 	unsigned int	(*adc_chan_select)(unsigned int chan);
+ 	unsigned int	adc_chan_mask;
++	unsigned int	temp_data[MAX_SENSOR_COUNT];
++	int		(*sample_start)(struct sun4i_gpadc_iio *info);
++	int		(*sample_end)(struct sun4i_gpadc_iio *info);
++	u32		ctrl0_map;
++	u32		ctrl2_map;
++	u32		sensor_en_map;
++	u32		filter_map;
++	u32		irq_clear_map;
++	u32		irq_control_map;
++	bool		has_bus_clk;
++	bool		has_bus_rst;
++	bool		has_mod_clk;
++	int		sensor_count;
++	bool		supports_nvmem;
++	bool		support_irq;
+ };
+ 
+ static const struct gpadc_data sun4i_gpadc_data = {
+@@ -65,6 +95,12 @@
+ 	.tp_adc_select = SUN4I_GPADC_CTRL1_TP_ADC_SELECT,
+ 	.adc_chan_select = &sun4i_gpadc_chan_select,
+ 	.adc_chan_mask = SUN4I_GPADC_CTRL1_ADC_CHAN_MASK,
++	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
++	.sample_start = sun4i_gpadc_sample_start,
++	.sample_end = sun4i_gpadc_sample_end,
++	.sensor_count = 1,
++	.supports_nvmem = false,
++	.support_irq = false,
+ };
+ 
+ static const struct gpadc_data sun5i_gpadc_data = {
+@@ -74,6 +110,12 @@
+ 	.tp_adc_select = SUN4I_GPADC_CTRL1_TP_ADC_SELECT,
+ 	.adc_chan_select = &sun4i_gpadc_chan_select,
+ 	.adc_chan_mask = SUN4I_GPADC_CTRL1_ADC_CHAN_MASK,
++	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
++	.sample_start = sun4i_gpadc_sample_start,
++	.sample_end = sun4i_gpadc_sample_end,
++	.sensor_count = 1,
++	.supports_nvmem = false,
++	.support_irq = false,
+ };
+ 
+ static const struct gpadc_data sun6i_gpadc_data = {
+@@ -83,12 +125,203 @@
+ 	.tp_adc_select = SUN6I_GPADC_CTRL1_TP_ADC_SELECT,
+ 	.adc_chan_select = &sun6i_gpadc_chan_select,
+ 	.adc_chan_mask = SUN6I_GPADC_CTRL1_ADC_CHAN_MASK,
++	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
++	.sample_start = sun4i_gpadc_sample_start,
++	.sample_end = sun4i_gpadc_sample_end,
++	.sensor_count = 1,
++	.supports_nvmem = false,
++	.support_irq = false,
+ };
+ 
+ static const struct gpadc_data sun8i_a33_gpadc_data = {
+ 	.temp_offset = -1662,
+ 	.temp_scale = 162,
+-	.tp_mode_en = SUN8I_GPADC_CTRL1_CHOP_TEMP_EN,
++	.tp_mode_en = SUN8I_A33_GPADC_CTRL1_CHOP_TEMP_EN,
++	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
++	.sample_start = sun4i_gpadc_sample_start,
++	.sample_end = sun4i_gpadc_sample_end,
++	.sensor_count = 1,
++	.supports_nvmem = false,
++	.support_irq = false,
++};
++
++static const struct gpadc_data sun8i_h3_ths_data = {
++	.temp_offset = -1791,
++	.temp_scale = -121,
++	.temp_data = {SUNXI_THS_TDATA0, 0, 0, 0},
++	.sample_start = sunxi_ths_sample_start,
++	.sample_end = sunxi_ths_sample_end,
++	.has_bus_clk = true,
++	.has_bus_rst = true,
++	.has_mod_clk = true,
++	.sensor_count = 1,
++	.supports_nvmem = true,
++	.support_irq = true,
++	.ctrl0_map = SUNXI_THS_ACQ0(0xff),
++	.ctrl2_map = SUNXI_THS_ACQ1(0x3f),
++	.sensor_en_map = SUNXI_THS_TEMP_SENSE_EN0,
++	.filter_map = SUNXI_THS_FILTER_EN |
++		SUNXI_THS_FILTER_TYPE(0x2),
++	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
++			SUNXI_THS_INTS_SHUT_INT_0   |
++			SUNXI_THS_INTS_TDATA_IRQ_0  |
++			SUNXI_THS_INTS_ALARM_OFF_0,
++	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
++		SUNXI_THS_TEMP_PERIOD(0x7),
++};
++
++static const struct gpadc_data sun8i_a83t_ths_data = {
++	.temp_offset = -2724,
++	.temp_scale = -70,
++	.temp_data = {SUNXI_THS_TDATA0,
++		SUNXI_THS_TDATA1,
++		SUNXI_THS_TDATA2,
++		0},
++	.sample_start = sunxi_ths_sample_start,
++	.sample_end = sunxi_ths_sample_end,
++	.sensor_count = 3,
++	.supports_nvmem = false,
++	.support_irq = true,
++	.ctrl0_map = SUNXI_THS_ACQ0(0x1f3),
++	.ctrl2_map = SUNXI_THS_ACQ1(0x1f3),
++	.sensor_en_map = SUNXI_THS_TEMP_SENSE_EN0 |
++		SUNXI_THS_TEMP_SENSE_EN1 |
++		SUNXI_THS_TEMP_SENSE_EN2,
++	.filter_map = SUNXI_THS_FILTER_EN |
++		SUNXI_THS_FILTER_TYPE(0x2),
++	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
++		SUNXI_THS_INTS_ALARM_INT_1 |
++		SUNXI_THS_INTS_ALARM_INT_2 |
++		SUNXI_THS_INTS_SHUT_INT_0  |
++		SUNXI_THS_INTS_SHUT_INT_1  |
++		SUNXI_THS_INTS_SHUT_INT_2  |
++		SUNXI_THS_INTS_TDATA_IRQ_0 |
++		SUNXI_THS_INTS_TDATA_IRQ_1 |
++		SUNXI_THS_INTS_TDATA_IRQ_2,
++	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN1 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN2 |
++		SUNXI_THS_TEMP_PERIOD(0x257),
++};
++
++static const struct gpadc_data sun50i_h5_ths_data = {
++	.temp_offset = -1872,
++	.temp_scale = -119,
++	.temp_data = {SUNXI_THS_TDATA0,
++		SUNXI_THS_TDATA1, 0, 0},
++	.sample_start = sunxi_ths_sample_start,
++	.sample_end = sunxi_ths_sample_end,
++	.has_bus_clk = true,
++	.has_bus_rst = true,
++	.has_mod_clk = true,
++	.sensor_count = 2,
++	.supports_nvmem = false,
++	.support_irq = true,
++	.ctrl0_map = SUNXI_THS_ACQ0(0x1f3),
++	.ctrl2_map = SUNXI_THS_ACQ1(0x1f3),
++	.sensor_en_map = SUNXI_THS_TEMP_SENSE_EN0 |
++		SUNXI_THS_TEMP_SENSE_EN1,
++	.filter_map = SUNXI_THS_FILTER_EN |
++		SUNXI_THS_FILTER_TYPE(0x2),
++	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
++		SUNXI_THS_INTS_ALARM_INT_1 |
++		SUNXI_THS_INTS_SHUT_INT_0   |
++		SUNXI_THS_INTS_SHUT_INT_1   |
++		SUNXI_THS_INTS_TDATA_IRQ_0  |
++		SUNXI_THS_INTS_TDATA_IRQ_1  |
++		SUNXI_THS_INTS_ALARM_OFF_0  |
++		SUNXI_THS_INTS_ALARM_OFF_1,
++	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN1 |
++		SUNXI_THS_TEMP_PERIOD(0x3a),
++};
++
++static const struct gpadc_data sun9i_a80_ths_data = {
++	.temp_offset = -2794,
++	.temp_scale = -67,
++	.temp_data = {SUNXI_THS_TDATA0,
++		SUNXI_THS_TDATA1,
++		SUNXI_THS_TDATA2,
++		SUNXI_THS_TDATA3},
++	.sample_start = sunxi_ths_sample_start,
++	.sample_end = sunxi_ths_sample_end,
++	.has_bus_clk = true,
++	.has_bus_rst = true,
++	.has_mod_clk = true,
++	.sensor_count = 4,
++	.supports_nvmem = false,
++	.support_irq = true,
++	.ctrl0_map = SUNXI_THS_ACQ0(0x1f3),
++	.ctrl2_map = SUNXI_THS_TEMP_SENSE_EN0 |
++		SUNXI_THS_TEMP_SENSE_EN1 |
++		SUNXI_THS_TEMP_SENSE_EN2 |
++		SUNXI_THS_TEMP_SENSE_EN3 |
++		SUNXI_THS_ACQ1(0x1f3),
++	.filter_map = SUNXI_THS_FILTER_EN |
++		SUNXI_THS_FILTER_TYPE(0x2),
++	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
++		SUNXI_THS_INTS_ALARM_INT_1 |
++		SUNXI_THS_INTS_ALARM_INT_2 |
++		SUNXI_THS_INTS_ALARM_INT_3 |
++		SUNXI_THS_INTS_SHUT_INT_0  |
++		SUNXI_THS_INTS_SHUT_INT_1  |
++		SUNXI_THS_INTS_SHUT_INT_2  |
++		SUNXI_THS_INTS_SHUT_INT_3  |
++		SUNXI_THS_INTS_TDATA_IRQ_0 |
++		SUNXI_THS_INTS_TDATA_IRQ_1 |
++		SUNXI_THS_INTS_TDATA_IRQ_2 |
++		SUNXI_THS_INTS_TDATA_IRQ_3,
++	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN1 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN2 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN3 |
++		SUNXI_THS_TEMP_PERIOD(0x3a),
++};
++
++static const struct gpadc_data sun50i_a64_ths_data = {
++	.temp_offset = -2170,
++	.temp_scale = -117,
++	.temp_data = {SUNXI_THS_TDATA0,
++		SUNXI_THS_TDATA1,
++		SUNXI_THS_TDATA2,
++		0},
++	.sample_start = sunxi_ths_sample_start,
++	.sample_end = sunxi_ths_sample_end,
++	.has_bus_clk = true,
++	.has_bus_rst = true,
++	.has_mod_clk = true,
++	.sensor_count = 3,
++	.supports_nvmem = false,
++	.support_irq = true,
++
++	/* The final sample period is calculated as follows:
++	 * (THERMAL_PER + 1) * 4096 / 24MHz * 2^(FILTER_TYPE + 1)
++	 *
++	 * This results to about 1Hz with these settings.
++	 */
++	.ctrl0_map = SUNXI_THS_ACQ0(0xff),
++	.ctrl2_map = SUNXI_THS_TEMP_SENSE_EN0 |
++		SUNXI_THS_TEMP_SENSE_EN1 |
++		SUNXI_THS_TEMP_SENSE_EN2 |
++		SUNXI_THS_ACQ1(0x3f),
++	.filter_map = SUNXI_THS_FILTER_EN |
++		SUNXI_THS_FILTER_TYPE(0x1),
++	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
++		SUNXI_THS_INTS_ALARM_INT_1 |
++		SUNXI_THS_INTS_ALARM_INT_2 |
++		SUNXI_THS_INTS_SHUT_INT_0  |
++		SUNXI_THS_INTS_SHUT_INT_1  |
++		SUNXI_THS_INTS_SHUT_INT_2  |
++		SUNXI_THS_INTS_TDATA_IRQ_0 |
++		SUNXI_THS_INTS_TDATA_IRQ_1 |
++		SUNXI_THS_INTS_TDATA_IRQ_2 |
++		SUNXI_THS_INTS_ALARM_OFF_0 |
++		SUNXI_THS_INTS_ALARM_OFF_1 |
++		SUNXI_THS_INTS_ALARM_OFF_2,
++	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN1 |
++		SUNXI_THS_INTC_TDATA_IRQ_EN2 |
++		SUNXI_THS_TEMP_PERIOD(0x7),
+ };
+ 
+ struct sun4i_gpadc_iio {
+@@ -103,6 +336,12 @@
+ 	atomic_t			ignore_temp_data_irq;
+ 	const struct gpadc_data		*data;
+ 	bool				no_irq;
++	struct clk			*bus_clk;
++	struct clk			*mod_clk;
++	struct reset_control		*reset;
++	int				sensor_id;
++	u32				calibration_data[2];
++	bool				has_calibration_data[2];
+ 	/* prevents concurrent reads of temperature and ADC */
+ 	struct mutex			mutex;
+ 	struct thermal_zone_device	*tzd;
+@@ -270,14 +509,15 @@
+ 	return sun4i_gpadc_read(indio_dev, channel, val, info->fifo_data_irq);
+ }
+ 
+-static int sun4i_gpadc_temp_read(struct iio_dev *indio_dev, int *val)
++static int sun4i_gpadc_temp_read(struct iio_dev *indio_dev, int *val,
++				int sensor)
+ {
+ 	struct sun4i_gpadc_iio *info = iio_priv(indio_dev);
+ 
+ 	if (info->no_irq) {
+ 		pm_runtime_get_sync(indio_dev->dev.parent);
+ 
+-		regmap_read(info->regmap, SUN4I_GPADC_TEMP_DATA, val);
++		regmap_read(info->regmap, info->data->temp_data[sensor], val);
+ 
+ 		pm_runtime_mark_last_busy(indio_dev->dev.parent);
+ 		pm_runtime_put_autosuspend(indio_dev->dev.parent);
+@@ -285,6 +525,11 @@
+ 		return 0;
+ 	}
+ 
++	if (info->data->support_irq) {
++		regmap_read(info->regmap, info->data->temp_data[sensor], val);
++		return 0;
++	}
++
+ 	return sun4i_gpadc_read(indio_dev, 0, val, info->temp_data_irq);
+ }
+ 
+@@ -324,7 +569,7 @@
+ 			ret = sun4i_gpadc_adc_read(indio_dev, chan->channel,
+ 						   val);
+ 		else
+-			ret = sun4i_gpadc_temp_read(indio_dev, val);
++			ret = sun4i_gpadc_temp_read(indio_dev, val, 0);
+ 
+ 		if (ret)
+ 			return ret;
+@@ -382,10 +627,19 @@
+ 	return IRQ_HANDLED;
+ }
+ 
+-static int sun4i_gpadc_runtime_suspend(struct device *dev)
++static irqreturn_t sunxi_irq_thread(int irq, void *data)
+ {
+-	struct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));
++	struct sun4i_gpadc_iio *info = data;
+ 
++	regmap_write(info->regmap, SUNXI_THS_STAT, info->data->irq_clear_map);
++
++	thermal_zone_device_update(info->tzd, THERMAL_EVENT_TEMP_SAMPLE);
++
++	return IRQ_HANDLED;
++}
++
++static int sun4i_gpadc_sample_end(struct sun4i_gpadc_iio *info)
++{
+ 	/* Disable the ADC on IP */
+ 	regmap_write(info->regmap, SUN4I_GPADC_CTRL1, 0);
+ 	/* Disable temperature sensor on IP */
+@@ -394,19 +648,51 @@
+ 	return 0;
+ }
+ 
+-static int sun4i_gpadc_runtime_resume(struct device *dev)
++static int sunxi_ths_sample_end(struct sun4i_gpadc_iio *info)
++{
++	/* Disable ths interrupt*/
++	regmap_write(info->regmap, SUNXI_THS_INTC, 0x0);
++	/* Disable temperature sensor */
++	regmap_write(info->regmap, SUNXI_THS_CTRL2, 0x0);
++
++	return 0;
++}
++
++static int sun4i_gpadc_runtime_suspend(struct device *dev)
+ {
+ 	struct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));
+ 
++	if (info->data->has_mod_clk)
++		clk_disable(info->mod_clk);
++
++	if (info->data->has_bus_clk)
++		clk_disable(info->bus_clk);
++
++	return info->data->sample_end(info);
++}
++
++static void sunxi_calibrate(struct sun4i_gpadc_iio *info)
++{
++	if (info->has_calibration_data[0])
++		regmap_write(info->regmap, SUNXI_THS_CDATA_0_1,
++			info->calibration_data[0]);
++
++	if (info->has_calibration_data[1])
++		regmap_write(info->regmap, SUNXI_THS_CDATA_2_3,
++			info->calibration_data[1]);
++}
++
++static int sun4i_gpadc_sample_start(struct sun4i_gpadc_iio *info)
++{
+ 	/* clkin = 6MHz */
+ 	regmap_write(info->regmap, SUN4I_GPADC_CTRL0,
+ 		     SUN4I_GPADC_CTRL0_ADC_CLK_DIVIDER(2) |
+ 		     SUN4I_GPADC_CTRL0_FS_DIV(7) |
+-		     SUN4I_GPADC_CTRL0_T_ACQ(63));
++		     SUNXI_THS_ACQ0(63));
+ 	regmap_write(info->regmap, SUN4I_GPADC_CTRL1, info->data->tp_mode_en);
+ 	regmap_write(info->regmap, SUN4I_GPADC_CTRL3,
+-		     SUN4I_GPADC_CTRL3_FILTER_EN |
+-		     SUN4I_GPADC_CTRL3_FILTER_TYPE(1));
++		     SUNXI_THS_FILTER_EN |
++		     SUNXI_THS_FILTER_TYPE(1));
+ 	/* period = SUN4I_GPADC_TPR_TEMP_PERIOD * 256 * 16 / clkin; ~0.6s */
+ 	regmap_write(info->regmap, SUN4I_GPADC_TPR,
+ 		     SUN4I_GPADC_TPR_TEMP_ENABLE |
+@@ -415,12 +701,60 @@
+ 	return 0;
+ }
+ 
++static int sunxi_ths_sample_start(struct sun4i_gpadc_iio *info)
++{
++	u32 value;
++	sunxi_calibrate(info);
++
++	if (info->data->ctrl0_map)
++		regmap_write(info->regmap, SUNXI_THS_CTRL0,
++			info->data->ctrl0_map);
++
++	regmap_write(info->regmap, SUNXI_THS_CTRL2,
++		info->data->ctrl2_map);
++
++	regmap_write(info->regmap, SUNXI_THS_STAT,
++			info->data->irq_clear_map);
++
++	regmap_write(info->regmap, SUNXI_THS_FILTER,
++		info->data->filter_map);
++
++	regmap_write(info->regmap, SUNXI_THS_INTC,
++		info->data->irq_control_map);
++
++	regmap_read(info->regmap, SUNXI_THS_CTRL2, &value);
++
++	regmap_write(info->regmap, SUNXI_THS_CTRL2,
++		info->data->sensor_en_map | value);
++
++	return 0;
++}
++
++static int sun4i_gpadc_runtime_resume(struct device *dev)
++{
++	struct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));
++
++	if (info->data->has_mod_clk)
++		clk_enable(info->mod_clk);
++
++	if (info->data->has_bus_clk)
++		clk_enable(info->bus_clk);
++
++	return info->data->sample_start(info);
++}
++
+ static int sun4i_gpadc_get_temp(void *data, int *temp)
+ {
+ 	struct sun4i_gpadc_iio *info = data;
+ 	int val, scale, offset;
+ 
+-	if (sun4i_gpadc_temp_read(info->indio_dev, &val))
++	if (sun4i_gpadc_temp_read(info->indio_dev, &val, info->sensor_id))
++		return -ETIMEDOUT;
++
++	/* Ignore first sample which is always zero. 0 is either too
++	 * cold or too hot, so we can safely ignore it
++	 */
++	if (val == 0)
+ 		return -ETIMEDOUT;
+ 
+ 	sun4i_gpadc_temp_scale(info->indio_dev, &scale);
+@@ -494,6 +828,26 @@
+ 		.compatible = "allwinner,sun8i-a33-ths",
+ 		.data = &sun8i_a33_gpadc_data,
+ 	},
++	{
++		.compatible = "allwinner,sun8i-h3-ths",
++		.data = &sun8i_h3_ths_data,
++	},
++	{
++		.compatible = "allwinner,sun8i-a83t-ths",
++		.data = &sun8i_a83t_ths_data,
++	},
++	{
++		.compatible = "allwinner,sun50i-h6-ths",
++		.data = &sun50i_h5_ths_data,
++	},
++	{
++		.compatible = "allwinner,sun9i-a80-ths",
++		.data = &sun9i_a80_ths_data,
++	},
++	{
++		.compatible = "allwinner,sun50i-a64-ths",
++		.data = &sun50i_a64_ths_data,
++	},
+ 	{ /* sentinel */ }
+ };
+ 
+@@ -504,12 +858,32 @@
+ 	struct resource *mem;
+ 	void __iomem *base;
+ 	int ret;
++	struct nvmem_cell *cell;
++	ssize_t cell_size;
++	u64 *cell_data;
++	int irq;
+ 
+ 	info->data = of_device_get_match_data(&pdev->dev);
+ 	if (!info->data)
+ 		return -ENODEV;
+ 
+-	info->no_irq = true;
++	if (info->data->support_irq) {
++		/* only the new versions of ths support right now irqs */
++		irq = platform_get_irq(pdev, 0);
++		if (irq < 0) {
++			dev_err(&pdev->dev, "failed to get IRQ: %d\n", irq);
++			return irq;
++		}
++
++		ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
++				sunxi_irq_thread, IRQF_ONESHOT,
++				dev_name(&pdev->dev), info);
++		if (ret)
++			return ret;
++
++	} else
++		info->no_irq = true;
++
+ 	indio_dev->num_channels = ARRAY_SIZE(sun8i_a33_gpadc_channels);
+ 	indio_dev->channels = sun8i_a33_gpadc_channels;
+ 
+@@ -518,6 +892,35 @@
+ 	if (IS_ERR(base))
+ 		return PTR_ERR(base);
+ 
++	info->has_calibration_data[0] = false;
++	info->has_calibration_data[1] = false;
++
++	if (!info->data->supports_nvmem)
++		goto no_nvmem;
++
++	cell = devm_nvmem_cell_get(&pdev->dev, "calibration");
++	if (IS_ERR(cell)) {
++		if (PTR_ERR(cell) == -EPROBE_DEFER)
++			return PTR_ERR(cell);
++	} else {
++		cell_data = (u64 *)nvmem_cell_read(cell, &cell_size);
++		devm_nvmem_cell_put(&pdev->dev, cell);
++		if (cell_size <= 4) {
++			info->has_calibration_data[0] = true;
++			info->calibration_data[0] = be32_to_cpu(cell_data[0] &
++					GENMASK(31, 0));
++		} else if (cell_size <= 8) {
++			info->has_calibration_data[0] = true;
++			info->calibration_data[0] = be32_to_cpu(cell_data[0] &
++					GENMASK(31, 0));
++			info->has_calibration_data[1] = true;
++			info->calibration_data[1] = be32_to_cpu(
++					(cell_data[0] >> 32) & GENMASK(31, 0));
++		}
++	}
++
++no_nvmem:
++
+ 	info->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+ 					     &sun4i_gpadc_regmap_config);
+ 	if (IS_ERR(info->regmap)) {
+@@ -526,10 +929,61 @@
+ 		return ret;
+ 	}
+ 
++	if (info->data->has_bus_rst) {
++		info->reset = devm_reset_control_get(&pdev->dev, NULL);
++		if (IS_ERR(info->reset)) {
++			ret = PTR_ERR(info->reset);
++			return ret;
++		}
++
++		ret = reset_control_deassert(info->reset);
++		if (ret)
++			return ret;
++	}
++
++	if (info->data->has_bus_clk) {
++		info->bus_clk = devm_clk_get(&pdev->dev, "bus");
++		if (IS_ERR(info->bus_clk)) {
++			ret = PTR_ERR(info->bus_clk);
++			goto assert_reset;
++		}
++
++		ret = clk_prepare_enable(info->bus_clk);
++		if (ret)
++			goto assert_reset;
++	}
++
++	if (info->data->has_mod_clk) {
++		info->mod_clk = devm_clk_get(&pdev->dev, "mod");
++		if (IS_ERR(info->mod_clk)) {
++			ret = PTR_ERR(info->mod_clk);
++			goto disable_bus_clk;
++		}
++
++		/* Running at 6MHz */
++		ret = clk_set_rate(info->mod_clk, 4000000);
++		if (ret)
++			goto disable_bus_clk;
++
++		ret = clk_prepare_enable(info->mod_clk);
++		if (ret)
++			goto disable_bus_clk;
++	}
++
+ 	if (IS_ENABLED(CONFIG_THERMAL_OF))
+ 		info->sensor_device = &pdev->dev;
+ 
+ 	return 0;
++
++disable_bus_clk:
++	if (info->data->has_bus_clk)
++		clk_disable_unprepare(info->bus_clk);
++
++assert_reset:
++	if (info->data->has_bus_rst)
++		reset_control_assert(info->reset);
++
++	return ret;
+ }
+ 
+ static int sun4i_gpadc_probe_mfd(struct platform_device *pdev,
+@@ -613,7 +1067,7 @@
+ {
+ 	struct sun4i_gpadc_iio *info;
+ 	struct iio_dev *indio_dev;
+-	int ret;
++	int ret, i;
+ 
+ 	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));
+ 	if (!indio_dev)
+@@ -639,16 +1093,21 @@
+ 	if (ret)
+ 		return ret;
+ 
+-	pm_runtime_set_autosuspend_delay(&pdev->dev,
+-					 SUN4I_GPADC_AUTOSUSPEND_DELAY);
+-	pm_runtime_use_autosuspend(&pdev->dev);
+-	pm_runtime_set_suspended(&pdev->dev);
+-	pm_runtime_enable(&pdev->dev);
++	if (!info->data->support_irq) {
++		pm_runtime_set_autosuspend_delay(&pdev->dev,
++						 SUN4I_GPADC_AUTOSUSPEND_DELAY);
++		pm_runtime_use_autosuspend(&pdev->dev);
++		pm_runtime_set_suspended(&pdev->dev);
++		pm_runtime_enable(&pdev->dev);
++	}
+ 
+ 	if (IS_ENABLED(CONFIG_THERMAL_OF)) {
+-		info->tzd = thermal_zone_of_sensor_register(info->sensor_device,
+-							    0, info,
+-							    &sun4i_ts_tz_ops);
++		for (i = 0; i < info->data->sensor_count; i++) {
++			info->sensor_id = i;
++			info->tzd = thermal_zone_of_sensor_register(
++					info->sensor_device,
++					i, info, &sun4i_ts_tz_ops);
++		}
+ 		/*
+ 		 * Do not fail driver probing when failing to register in
+ 		 * thermal because no thermal DT node is found.
+@@ -661,6 +1120,9 @@
+ 		}
+ 	}
+ 
++	if (info->data->support_irq)
++		info->data->sample_start(info);
++
+ 	ret = devm_iio_device_register(&pdev->dev, indio_dev);
+ 	if (ret < 0) {
+ 		dev_err(&pdev->dev, "could not register the device\n");
+@@ -690,11 +1152,23 @@
+ 	if (!IS_ENABLED(CONFIG_THERMAL_OF))
+ 		return 0;
+ 
++	if (info->data->support_irq)
++		info->data->sample_end(info);
++
+ 	thermal_zone_of_sensor_unregister(info->sensor_device, info->tzd);
+ 
+ 	if (!info->no_irq)
+ 		iio_map_array_unregister(indio_dev);
+ 
++	if (info->data->has_mod_clk)
++		clk_disable_unprepare(info->mod_clk);
++
++	if (info->data->has_bus_clk)
++		clk_disable_unprepare(info->bus_clk);
++
++	if (info->data->has_bus_rst)
++		reset_control_assert(info->reset);
++
+ 	return 0;
+ }
+ 
+--- a/drivers/iio/adc/Kconfig	2019-10-01 09:26:13.000000000 +0300
++++ b/drivers/iio/adc/Kconfig	2019-03-12 10:34:30.454795338 +0200
+@@ -674,7 +700,7 @@
+ config SUN4I_GPADC
+ 	tristate "Support for the Allwinner SoCs GPADC"
+ 	depends on IIO
+-	depends on MFD_SUN4I_GPADC || MACH_SUN8I
++	depends on MFD_SUN4I_GPADC || MACH_SUN8I || MACH_SUN50I || MACH_SUN9I
+ 	depends on THERMAL || !THERMAL_OF
+ 	help
+ 	  Say yes here to build support for Allwinner (A10, A13 and A31) SoCs
+--- a/include/linux/mfd/sun4i-gpadc.h	2019-10-01 09:26:13.000000000 +0300
++++ b/include/linux/mfd/sun4i-gpadc.h	2019-03-12 10:34:30.334798888 +0200
+@@ -17,7 +17,6 @@
+ #define SUN4I_GPADC_CTRL0_ADC_CLK_SELECT		BIT(22)
+ #define SUN4I_GPADC_CTRL0_ADC_CLK_DIVIDER(x)		((GENMASK(1, 0) & (x)) << 20)
+ #define SUN4I_GPADC_CTRL0_FS_DIV(x)			((GENMASK(3, 0) & (x)) << 16)
+-#define SUN4I_GPADC_CTRL0_T_ACQ(x)			(GENMASK(15, 0) & (x))
+ 
+ #define SUN4I_GPADC_CTRL1				0x04
+ 
+@@ -38,9 +37,9 @@
+ #define SUN6I_GPADC_CTRL1_ADC_CHAN_SELECT(x)		(GENMASK(3, 0) & BIT(x))
+ #define SUN6I_GPADC_CTRL1_ADC_CHAN_MASK			GENMASK(3, 0)
+ 
+-/* TP_CTRL1 bits for sun8i SoCs */
+-#define SUN8I_GPADC_CTRL1_CHOP_TEMP_EN			BIT(8)
+-#define SUN8I_GPADC_CTRL1_GPADC_CALI_EN			BIT(7)
++/* TP_CTRL1 bits for A33 */
++#define SUN8I_A33_GPADC_CTRL1_CHOP_TEMP_EN		BIT(8)
++#define SUN8I_A33_GPADC_CTRL1_GPADC_CALI_EN		BIT(7)
+ 
+ #define SUN4I_GPADC_CTRL2				0x08
+ 
+@@ -51,9 +50,6 @@
+ 
+ #define SUN4I_GPADC_CTRL3				0x0c
+ 
+-#define SUN4I_GPADC_CTRL3_FILTER_EN			BIT(2)
+-#define SUN4I_GPADC_CTRL3_FILTER_TYPE(x)		(GENMASK(1, 0) & (x))
+-
+ #define SUN4I_GPADC_TPR					0x18
+ 
+ #define SUN4I_GPADC_TPR_TEMP_ENABLE			BIT(16)
+@@ -90,6 +86,62 @@
+ /* 10s delay before suspending the IP */
+ #define SUN4I_GPADC_AUTOSUSPEND_DELAY			10000
+ 
++/* SUNXI_THS COMMON REGISTERS + DEFINES */
++#define SUNXI_THS_CTRL0					0x00
++#define SUNXI_THS_CTRL2					0x40
++#define SUNXI_THS_INTC					0x44
++#define SUNXI_THS_STAT					0x48
++#define SUNXI_THS_FILTER				0x70
++#define SUNXI_THS_CDATA_0_1				0x74
++#define SUNXI_THS_CDATA_2_3				0x78
++#define SUNXI_THS_TDATA0				0x80
++#define SUNXI_THS_TDATA1				0x84
++#define SUNXI_THS_TDATA2				0x88
++#define SUNXI_THS_TDATA3				0x8c
++
++#define SUNXI_THS_FILTER_EN				BIT(2)
++#define SUNXI_THS_FILTER_TYPE(x)			(GENMASK(1, 0) & (x))
++#define SUNXI_THS_ACQ0(x)				(GENMASK(15, 0) & (x))
++#define SUNXI_THS_ACQ1(x)				(GENMASK(31, 16) & ((x) << 16))
++
++#define SUNXI_THS_TEMP_SENSE_EN0			BIT(0)
++#define SUNXI_THS_TEMP_SENSE_EN1			BIT(1)
++#define SUNXI_THS_TEMP_SENSE_EN2			BIT(2)
++#define SUNXI_THS_TEMP_SENSE_EN3			BIT(3)
++
++#define SUNXI_THS_TEMP_PERIOD(x)			(GENMASK(31, 12) & ((x) << 12))
++
++#define SUNXI_THS_INTS_ALARM_OFF_2			BIT(14)
++#define SUNXI_THS_INTS_ALARM_OFF_1			BIT(13)
++#define SUNXI_THS_INTS_ALARM_OFF_0			BIT(12)
++#define SUNXI_THS_INTS_TDATA_IRQ_3			BIT(11)
++#define SUNXI_THS_INTS_TDATA_IRQ_2			BIT(10)
++#define SUNXI_THS_INTS_TDATA_IRQ_1			BIT(9)
++#define SUNXI_THS_INTS_TDATA_IRQ_0			BIT(8)
++#define SUNXI_THS_INTS_SHUT_INT_3			BIT(7)
++#define SUNXI_THS_INTS_SHUT_INT_2			BIT(6)
++#define SUNXI_THS_INTS_SHUT_INT_1			BIT(5)
++#define SUNXI_THS_INTS_SHUT_INT_0			BIT(4)
++#define SUNXI_THS_INTS_ALARM_INT_3			BIT(3)
++#define SUNXI_THS_INTS_ALARM_INT_2			BIT(2)
++#define SUNXI_THS_INTS_ALARM_INT_1			BIT(1)
++#define SUNXI_THS_INTS_ALARM_INT_0			BIT(0)
++
++#define SUNXI_THS_INTC_TDATA_IRQ_EN3			BIT(11)
++#define SUNXI_THS_INTC_TDATA_IRQ_EN2			BIT(10)
++#define SUNXI_THS_INTC_TDATA_IRQ_EN1			BIT(9)
++#define SUNXI_THS_INTC_TDATA_IRQ_EN0			BIT(8)
++#define SUNXI_THS_INTC_SHUT_INT_EN3			BIT(7)
++#define SUNXI_THS_INTC_SHUT_INT_EN2			BIT(6)
++#define SUNXI_THS_INTC_SHUT_INT_EN1			BIT(5)
++#define SUNXI_THS_INTC_SHUT_INT_EN0			BIT(4)
++#define SUNXI_THS_INTC_ALARM_INT_EN3			BIT(3)
++#define SUNXI_THS_INTC_ALARM_INT_EN2			BIT(2)
++#define SUNXI_THS_INTC_ALARM_INT_EN1			BIT(1)
++#define SUNXI_THS_INTC_ALARM_INT_EN0			BIT(0)
++
++#define MAX_SENSOR_COUNT				4
++
+ struct sun4i_gpadc_dev {
+ 	struct device			*dev;
+ 	struct regmap			*regmap;
--- a/target/linux/sunxi/patches-4.14/208-add-vdd-cpux-regulator-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/208-add-vdd-cpux-regulator-opi-zero.patch	2021-01-22 00:11:49.812136809 +0200
@@ -0,0 +1,26 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -102,6 +120,23 @@
+ 		enable-active-high;
+ 		gpio = <&pio 0 20 GPIO_ACTIVE_HIGH>;
+ 	};
++
++	reg_vdd_cpux: vdd-cpux-regulator {
++		compatible = "regulator-gpio";
++		regulator-name = "vdd-cpux";
++		regulator-type = "voltage";
++		regulator-boot-on;
++		regulator-always-on;
++		regulator-min-microvolt = <1100000>;
++		regulator-max-microvolt = <1300000>;
++		regulator-ramp-delay = <50>; /* 4ms */
++
++		gpios = <&r_pio 0 6 GPIO_ACTIVE_HIGH>; /* PL6 */
++		enable-active-high;
++		gpios-states = <1>;
++		states = <1100000 0
++			  1300000 1>;
++	};
+ 
+ 	wifi_pwrseq: wifi_pwrseq {
+ 		compatible = "mmc-pwrseq-simple";
--- a/target/linux/sunxi/patches-4.14/209-dts-add-orangepi-zero-lts.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/209-dts-add-orangepi-zero-lts.patch	2021-01-22 00:11:49.812136809 +0200
@@ -0,0 +1,70 @@
+--- a/arch/arm/boot/dts/Makefile
++++ b/arch/arm/boot/dts/Makefile
+@@ -917,6 +930,7 @@ dtb-$(CONFIG_MACH_SUN8I) += \
+ 	sun8i-a83t-bananapi-m3.dtb \
+ 	sun8i-a83t-cubietruck-plus.dtb \
+ 	sun8i-h2-plus-orangepi-r1.dtb \
++	sun8i-h2-plus-orangepi-zero-lts.dtb \
+ 	sun8i-h2-plus-orangepi-zero.dtb \
+ 	sun8i-h3-bananapi-m2-plus.dtb \
+ 	sun8i-h3-beelink-x2.dtb \
+--- /dev/null
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero-lts.dts
+@@ -0,0 +1,57 @@
++/*
++ * Copyright (C) 2017 Icenowy Zheng <icenowy@aosc.xyz>
++ *
++ * This file is dual-licensed: you can use it either under the terms
++ * of the GPL or the X11 license, at your option. Note that this dual
++ * licensing only applies to this file, and not this project as a
++ * whole.
++ *
++ *  a) This file is free software; you can redistribute it and/or
++ *     modify it under the terms of the GNU General Public License as
++ *     published by the Free Software Foundation; either version 2 of the
++ *     License, or (at your option) any later version.
++ *
++ *     This file is distributed in the hope that it will be useful,
++ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
++ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ *     GNU General Public License for more details.
++ *
++ * Or, alternatively,
++ *
++ *  b) Permission is hereby granted, free of charge, to any person
++ *     obtaining a copy of this software and associated documentation
++ *     files (the "Software"), to deal in the Software without
++ *     restriction, including without limitation the rights to use,
++ *     copy, modify, merge, publish, distribute, sublicense, and/or
++ *     sell copies of the Software, and to permit persons to whom the
++ *     Software is furnished to do so, subject to the following
++ *     conditions:
++ *
++ *     The above copyright notice and this permission notice shall be
++ *     included in all copies or substantial portions of the Software.
++ *
++ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
++ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
++ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
++ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
++ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
++ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
++ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
++ *     OTHER DEALINGS IN THE SOFTWARE.
++ */
++
++/* Orange Pi Zero Lts is based on Orange Pi Zero design */
++#include "sun8i-h2-plus-orangepi-zero.dts"
++
++/ {
++	model = "Xunlong Orange Pi Zero Lts";
++	compatible = "xunlong,orangepi-zero-lts", "allwinner,sun8i-h2-plus";
++
++};
++
++&cpu_hot_trip {
++	temperature = <32500>; /* ~65°C */
++};
++&cpu_very_hot_trip {
++	temperature = <45000>; /* ~90°C */
++};
--- a/target/linux/sunxi/patches-4.14/210-add-spdif-PA17-red_led-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/210-add-spdif-PA17-red_led-opi-zero.patch	2021-01-22 00:11:49.812136809 +0200
@@ -0,0 +1,40 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts	2020-01-29 16:02:39.000000000 +0200
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts	2020-02-01 11:37:12.000000000 +0200
+@@ -125,6 +150,24 @@
+ 		reset-gpios = <&r_pio 0 7 GPIO_ACTIVE_LOW>;
+ 		post-power-on-delay-ms = <200>;
+ 	};
++
++	sound_spdif {
++		compatible = "simple-audio-card";
++		simple-audio-card,name = "On-board SPDIF";
++
++		simple-audio-card,cpu {
++			sound-dai = <&spdif>;
++		};
++
++		simple-audio-card,codec {
++			sound-dai = <&spdif_out>;
++		};
++	};
++
++	spdif_out: spdif-out {
++		#sound-dai-cells = <0>;
++		compatible = "linux,spdif-dit";
++	};
+ 
+ 	soc {
+ 		ths: thermal-sensor@1c25000 {
+@@ -298,6 +310,12 @@
+ 	pinctrl-0 = <&uart2_pins>;
+ 	status = "disabled";
+ };
++
++&spdif {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spdif_tx_pins_a>;
++	status = "disabled";
++};
+ 
+ &usb_otg {
+ 	dr_mode = "peripheral";
--- a/target/linux/sunxi/patches-4.14/211-add-button-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/211-add-button-opi-zero.patch	2021-01-22 00:11:49.812136809 +0200
@@ -0,0 +1,109 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts	2020-01-29 16:02:39.000000000 +0200
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts	2020-02-01 11:37:12.000000000 +0200
+@@ -156,6 +170,76 @@
+ 			#thermal-sensor-cells = <0>;
+ 		};
+ 	};
++
++	gpio-keys-user {
++		compatible = "gpio-keys";
++		pinctrl-names = "default";
++		pinctrl-0 = <&gpio_keys>;
++		status = "disabled";
++
++		g-keys_volup {
++			label = "GPIO KEY_VOLUMEUP";
++			linux,code = <115>; /* 115, see /usr/include/linux/input-event-codes.h */
++			gpios = <&pio 0 16 1>; /* PA16 GPIO_ACTIVE_LOW */
++		};
++
++		g-keys_voldown {
++			label = "GPIO KEY_VOLUMEDOWN";
++			linux,code = <114>; /* 114, see /usr/include/linux/input-event-codes.h */
++			gpios = <&pio 0 15 1>; /* PA15 GPIO_ACTIVE_LOW */
++		};
++
++		g-keys_power {
++			label = "GPIO KEY_POWER";
++			linux,code = <116>; /* 116, see /usr/include/linux/input-event-codes.h */
++			gpios = <&pio 0 14 1>; /* PA14 GPIO_ACTIVE_LOW */
++		};
++
++		g-keys_chanup {
++			label = "GPIO KEY_CHANNELUP";
++			linux,code = <402>; /* 402, see /usr/include/linux/input-event-codes.h */
++			gpios = <&pio 0 13 1>; /* PA13 GPIO_ACTIVE_LOW */
++		};
++
++		g-keys_chandown {
++			label = "GPIO KEY_CHANNELDOWN";
++			linux,code = <403>; /* 403, see /usr/include/linux/input-event-codes.h */
++			gpios = <&pio 0 2 1>; /* PA2 GPIO_ACTIVE_LOW */
++		};
++	};
++
++	rotary_button {
++		compatible = "gpio-keys";
++		pinctrl-names = "default";
++		pinctrl-0 = <&pinctrl_button>;
++		status = "disabled";
++
++		rotary_button_enter {
++			label = "ENTER";
++			linux,code = <99>; /* KEY_SYSRQ - see linux/input.h */
++			gpios = <&pio 0 0 1>; /* PA0 GPIO_ACTIVE_LOW */
++		};
++	};
++
++	rotary_axis {
++		/* https://mchehab.fedorapeople.org/kernel_docs/input/devices/rotary-encoder.html */
++		compatible = "rotary-encoder";
++		pinctrl-names = "default";
++		pinctrl-0 = <&pinctrl_rotary>;
++		gpios = <&pio 0 1 1>, <&pio 0 3 1>; /* PA1 PA3 GPIO_ACTIVE_LOW */
++		linux,axis = <1>; /* REL_Y */
++		rotary-encoder,relative-axis;
++		rotary-encoder,half-period;
++		status = "disabled";
++	};
++
++	pps {
++		compatible = "pps-gpio";
++		pinctrl-names = "default";
++		pinctrl-0 = <&pps_pins>;
++		gpios = <&pio 0 7 0>; /* PA7 */
++		status = "disabled";
++	};
+ 
+ 	thermal-zones {
+ 		cpu_thermal: cpu_thermal {
+@@ -279,6 +299,29 @@
+ 		drive = <SUN4I_PINCTRL_10_MA>;
+ 		pull = <SUN4I_PINCTRL_NO_PULL>;
+ 	};
++
++	gpio_keys: gpio_keys {
++		pins = "PA13","PA14","PA15","PA16","PA2";
++		function = "gpio_in";
++		bias-pull-up;
++	};
++
++	pinctrl_button: pinctrl_button {
++		pins = "PA0";
++		function = "gpio_in";
++		bias-pull-up;
++	};
++
++	pinctrl_rotary: pinctrl_rotary {
++		pins = "PA1","PA3";
++		function = "gpio_in";
++		bias-pull-up;
++	};
++
++	pps_pins: pps_pins {
++		pins = "PA7";
++		function = "gpio_in";
++	};
+ };
+ 
+ &pwm {
--- a/target/linux/sunxi/image/cortex-a7.mk	2021-03-02 21:21:50.746649436 +0200
+++ b/target/linux/sunxi/image/cortex-a7.mk	2021-02-09 23:50:06.681229639 +0200
@@ -8,6 +8,18 @@
 
 ifeq ($(SUBTARGET),cortexa7)
 
+define Build/append-uboot
+       dd if=$(STAGING_DIR_IMAGE)/$(DEVICE_NAME)-u-boot-with-spl.bin >> $@
+endef
+
+define Build/add-scr
+       dd if=$(STAGING_DIR_IMAGE)/$(DEVICE_NAME)-boot.scr >> $@
+endef
+
+define Build/add-dtb
+       dd if=$(DTS_DIR)/$(SUNXI_DTS).dtb >> $@
+endef
+
 define Device/sun7i-a20-olinuxino-lime
   DEVICE_TITLE:=Olimex A20-OLinuXino-LIME
   DEVICE_PACKAGES:=kmod-ata-core kmod-ata-sunxi kmod-rtc-sunxi
@@ -110,7 +122,20 @@
 
 define Device/sun8i-h2-plus-orangepi-zero
   DEVICE_TITLE:=Xunlong Orange Pi Zero
-  DEVICE_PACKAGES:=kmod-rtc-sunxi
+  FILESYSTEMS := squashfs
+  IMAGES := sysupgrade.bin dtb # fullflash.bin boot.bin SCR.bin
+  IMAGE_SIZE := 15808k
+  BOOT_SIZE := 512k
+  DTB_SIZE := 64k
+  BLOCKSIZE := 4k
+  IMAGE/sysupgrade.bin := append-kernel | append-rootfs | pad-rootfs | append-metadata | check-size $$$$(IMAGE_SIZE)
+#  IMAGE/fullflash.bin := append-uboot | pad-to $$$$(BOOT_SIZE) | add-dtb | pad-to $$$$(DTB_SIZE) | \
+#			append-kernel | append-rootfs | pad-rootfs
+#  IMAGE/boot.bin := append-uboot | pad-to $$$$(BLOCKSIZE)
+#  IMAGE/SCR.bin := add-scr | pad-to $$$$(BLOCKSIZE)
+  IMAGE/dtb := add-dtb | pad-to $$$$(BLOCKSIZE)
+  DEVICE_PACKAGES:=kmod-rtc-sunxi kmod-xradio \
+	boot-config
   SUPPORTED_DEVICES:=xunlong,orangepi-zero
   SUNXI_DTS:=sun8i-h2-plus-orangepi-zero
 endef
@@ -118,9 +143,45 @@
 TARGET_DEVICES += sun8i-h2-plus-orangepi-zero
 
 
+define Device/sun8i-h2-plus-orangepi-zero-lts
+  DEVICE_TITLE:=Xunlong Orange Pi Zero LTS
+  FILESYSTEMS := squashfs
+  IMAGES := sysupgrade.bin dtb # fullflash.bin boot.bin SCR.bin
+  IMAGE_SIZE := 15808k
+  BOOT_SIZE := 512k
+  DTB_SIZE := 64k
+  BLOCKSIZE := 4k
+  IMAGE/sysupgrade.bin := append-kernel | append-rootfs | pad-rootfs | append-metadata | check-size $$$$(IMAGE_SIZE)
+#  IMAGE/fullflash.bin := append-uboot | pad-to $$$$(BOOT_SIZE) | add-dtb | pad-to $$$$(DTB_SIZE) | \
+#			append-kernel | append-rootfs | pad-rootfs
+#  IMAGE/boot.bin := append-uboot | pad-to $$$$(BLOCKSIZE)
+#  IMAGE/SCR.bin := add-scr | pad-to $$$$(BLOCKSIZE)
+  IMAGE/dtb := add-dtb | pad-to $$$$(BLOCKSIZE)
+  DEVICE_PACKAGES:=kmod-rtc-sunxi kmod-xradio \
+	boot-config
+  SUPPORTED_DEVICES:=xunlong,orangepi-zero-lts
+  SUNXI_DTS:=sun8i-h2-plus-orangepi-zero-lts
+endef
+
+TARGET_DEVICES += sun8i-h2-plus-orangepi-zero-lts
+
+
 define Device/sun8i-h2-plus-orangepi-r1
   DEVICE_TITLE:=Xunlong Orange Pi R1
-  DEVICE_PACKAGES:=kmod-rtc-sunxi kmod-usb-net kmod-usb-net-rtl8152
+  FILESYSTEMS := squashfs
+  IMAGES := sysupgrade.bin dtb # fullflash.bin boot.bin SCR.bin
+  IMAGE_SIZE := 15808k
+  BOOT_SIZE := 512k
+  DTB_SIZE := 64k
+  BLOCKSIZE := 4k
+  IMAGE/sysupgrade.bin := append-kernel | append-rootfs | pad-rootfs | append-metadata | check-size $$$$(IMAGE_SIZE)
+#  IMAGE/fullflash.bin := append-uboot | pad-to $$$$(BOOT_SIZE) | add-dtb | pad-to $$$$(DTB_SIZE) | \
+#			append-kernel | append-rootfs | pad-rootfs
+#  IMAGE/boot.bin := append-uboot | pad-to $$$$(BLOCKSIZE)
+#  IMAGE/SCR.bin := add-scr | pad-to $$$$(BLOCKSIZE)
+  IMAGE/dtb := add-dtb | pad-to $$$$(BLOCKSIZE)
+  DEVICE_PACKAGES:=kmod-rtc-sunxi kmod-usb-net kmod-usb-net-rtl8152 kmod-rtl8189es \
+	boot-config
   SUPPORTED_DEVICES:=xunlong,orangepi-r1
   SUNXI_DTS:=sun8i-h2-plus-orangepi-r1
 endef
--- a/target/linux/sunxi/base-files/etc/rc.local	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/base-files/etc/rc.local	2021-01-22 00:11:49.812136809 +0200
@@ -0,0 +1,7 @@
+# Put your custom commands here that should be executed once
+# the system init finished. By default this file does nothing.
+
+amixer -c 0 -q set "Line Out" 80%+ unmute &
+amixer -c 0 -q set "DAC" 100%+ unmute &
+
+exit 0
--- a/package/boot/uboot-sunxi/patches/001-add-orangepi-zero-lts.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/package/boot/uboot-sunxi/patches/001-add-orangepi-zero-lts.patch	2021-02-10 00:43:51.906733867 +0200
@@ -0,0 +1,163 @@
+--- a/include/spi.h
++++ b/include/spi.h
+@@ -10,6 +12,8 @@
+ #define _SPI_H_
+ 
+ #include <common.h>
++
++#define AHB_GATE_OFFSET_SPI0		20
+ 
+ /* SPI mode flags */
+ #define SPI_CPHA	BIT(0)			/* clock phase */
+--- a/include/configs/sun8i.h	2020-04-13 18:02:18.000000000 +0300
++++ b/include/configs/sun8i.h	2020-04-27 13:18:42.645124351 +0300
+@@ -16,6 +22,14 @@
+ #define CONFIG_USB_EHCI_SUNXI
+ #endif
+ 
++#define CONFIG_BOOTCOMMAND	"sf probe 0; " \
++				"sf read 0x43000000 0x80000 0x10000; " \
++				"sf read 0x42000000 0x90000 0x400000; " \
++				"bootm 0x42000000 - 0x43000000 "
++
++#define CONFIG_BOOTARGS	"setenv bootargs console=ttyS0,115200 earlyprintk rootfstype=squashfs " \
++				"mtdparts=spi0.0:512k(uboot),64k(dtb),-(firmware) "
++
+ /*
+  * Include common sunxi configuration where most the settings are
+  */
+--- a/arch/arm/dts/sun8i-h2-plus-orangepi-zero.dts	2020-04-13 18:02:18.000000000 +0300
++++ b/arch/arm/dts/sun8i-h2-plus-orangepi-zero.dts	2020-04-27 13:21:09.376776939 +0300
+@@ -59,6 +59,7 @@
+ 		/* ethernet0 is the H3 emac, defined in sun8i-h3.dtsi */
+ 		ethernet0 = &emac;
+ 		ethernet1 = &xr819;
++		spi0 = &spi0;
+ 	};
+ 
+ 	chosen {
+@@ -144,7 +165,7 @@
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
+-	status = "disabled";
++	status = "okay";
+ 
+ 	flash@0 {
+ 		#address-cells = <1>;
+@@ -152,6 +173,28 @@
+ 		compatible = "mxicy,mx25l1606e", "winbond,w25q128";
+ 		reg = <0>;
+ 		spi-max-frequency = <40000000>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <0x01>;
++			#size-cells = <0x01>;
++
++			partition@0 {
++				label = "uboot";
++				reg = <0x0 0x80000>;
++			};
++
++			partition@80000 {
++				label = "dtb";
++				reg = <0x80000 0x10000>;
++			};
++
++			partition@90000 {
++				compatible = "firmware";
++				label = "firmware";
++				reg = <0x90000 0xf70000>;
++			};
++		};
+ 	};
+ };
+ 
+--- a/configs/orangepi_zero_defconfig	2020-04-13 18:02:18.000000000 +0300
++++ b/configs/orangepi_zero_defconfig	2020-04-26 23:25:47.021081652 +0300
+@@ -15,3 +15,16 @@
+ CONFIG_SUN8I_EMAC=y
+ CONFIG_USB_EHCI_HCD=y
+ CONFIG_SYS_USB_EVENT_POLL_VIA_INT_QUEUE=y
++CONFIG_USB_OHCI_HCD=y
++CONFIG_SPI=y
++CONFIG_SUN4I_SPI=y
++CONFIG_CMD_SF=y
++CONFIG_CMD_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_DM_SPI_FLASH=y
++CONFIG_SPL_SPI_BOOT=y
++CONFIG_SPI_FLASH_DATAFLASH=y
++CONFIG_SPI_FLASH=y
++CONFIG_SPI_FLASH_MTD=y
++CONFIG_SPI_FLASH_WINBOND=y
++CONFIG_SPI_FLASH_MACRONIX=y
+--- a/arch/arm/dts/Makefile	2019-01-15 00:02:36.000000000 +0200
++++ b/arch/arm/dts/Makefile	2019-05-03 17:50:22.000000000 +0300
+@@ -376,6 +376,7 @@
+ 	sun8i-h2-plus-libretech-all-h3-cc.dtb \
+ 	sun8i-h2-plus-orangepi-r1.dtb \
+ 	sun8i-h2-plus-orangepi-zero.dtb \
++	sun8i-h2-plus-orangepi-zero-lts.dtb \
+ 	sun8i-h3-bananapi-m2-plus.dtb \
+ 	sun8i-h3-libretech-all-h3-cc.dtb \
+ 	sun8i-h3-nanopi-m1.dtb \
+--- /dev/null
++++ b/arch/arm/dts/sun8i-h2-plus-orangepi-zero-lts.dts
+@@ -0,0 +1,9 @@
++
++/* Orange Pi Zero Lts is based on Orange Pi Zero design */
++#include "sun8i-h2-plus-orangepi-zero.dts"
++
++/ {
++	model = "Xunlong Orange Pi Zero Lts";
++	compatible = "xunlong,orangepi-zero-lts", "allwinner,sun8i-h2-plus";
++
++};
+--- /dev/null
++++ b/configs/orangepi_zero_lts_defconfig
+@@ -0,0 +1,28 @@
++CONFIG_ARM=y
++CONFIG_ARCH_SUNXI=y
++CONFIG_SPL=y
++CONFIG_MACH_SUN8I_H3=y
++CONFIG_DRAM_CLK=624
++CONFIG_DRAM_ZQ=3881979
++CONFIG_DRAM_ODT_EN=y
++CONFIG_VIDEO_DE2=y
++CONFIG_NR_DRAM_BANKS=1
++# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
++CONFIG_CONSOLE_MUX=y
++# CONFIG_CMD_FLASH is not set
++CONFIG_DEFAULT_DEVICE_TREE="sun8i-h2-plus-orangepi-zero-lts"
++CONFIG_SUN8I_EMAC=y
++CONFIG_USB_EHCI_HCD=y
++CONFIG_SYS_USB_EVENT_POLL_VIA_INT_QUEUE=y
++CONFIG_SPI=y
++CONFIG_SUN4I_SPI=y
++CONFIG_CMD_SF=y
++CONFIG_CMD_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_DM_SPI_FLASH=y
++CONFIG_SPL_SPI_BOOT=y
++CONFIG_SPI_FLASH_DATAFLASH=y
++CONFIG_SPI_FLASH=y
++CONFIG_SPI_FLASH_MTD=y
++CONFIG_SPI_FLASH_WINBOND=y
++CONFIG_SPI_FLASH_MACRONIX=y
+--- a/board/sunxi/MAINTAINERS	2019-01-15 00:02:36.000000000 +0200
++++ b/board/sunxi/MAINTAINERS	2019-05-03 17:50:22.000000000 +0300
+@@ -355,6 +355,12 @@
+ S:	Maintained
+ F:	configs/orangepi_zero_defconfig
+ 
++ORANGEPI ZERO LTS BOARD
++M:	Icenowy Zheng <icenowy@aosc.xyz>
++M:	Semen Kreyda <aswerklon@gmail.com>
++S:	Maintained
++F:	configs/orangepi_zero_lts_defconfig
++
+ ORANGEPI ZERO PLUS BOARD
+ M:	Hauke Mehrtens <hauke@hauke-m.de>
+ S:	Maintained
--- a/package/boot/uboot-sunxi/Makefile	2021-03-02 21:21:49.554680340 +0200
+++ b/package/boot/uboot-sunxi/Makefile	2021-02-10 00:18:56.314879729 +0200
@@ -156,6 +156,12 @@
   BUILD_DEVICES:=sun8i-h2-plus-orangepi-zero
 endef
 
+define U-Boot/orangepi_zero_lts
+  BUILD_SUBTARGET:=cortexa7
+  NAME:=Orange Pi Zero Lts (H2+)
+  BUILD_DEVICES:=sun8i-h2-plus-orangepi-zero-lts
+endef
+
 define U-Boot/orangepi_one
   BUILD_SUBTARGET:=cortexa7
   NAME:=Orange Pi One (H3)
@@ -271,6 +277,7 @@
 	nanopi_neo_plus2 \
 	nanopi_neo2 \
 	orangepi_zero \
+	orangepi_zero_lts \
 	orangepi_r1 \
 	orangepi_one \
 	orangepi_pc \
--- a/package/kernel/mac80211/files/lib/wifi/mac80211.sh	2021-03-02 21:21:49.650677851 +0200
+++ b/package/kernel/mac80211/files/lib/wifi/mac80211.sh	2021-01-22 00:11:49.812136809 +0200
@@ -1,5 +1,8 @@
 #!/bin/sh
 append DRIVERS "mac80211"
+ 
+board=$(cat /tmp/sysinfo/board_name)
+boardname="${board##*,}"
 
 lookup_phy() {
 	[ -n "$phy" ] && {
@@ -77,7 +80,7 @@
 		[ "$found" -gt 0 ] && continue
 
 		mode_band="g"
-		channel="11"
+		channel="1"
 		htmode=""
 		ht_capab=""
 
@@ -113,16 +116,18 @@
 			set wireless.radio${devidx}.hwmode=11${mode_band}
 			${dev_id}
 			${ht_capab}
-			set wireless.radio${devidx}.disabled=1
+			set wireless.radio${devidx}.disabled=0
 
 			set wireless.default_radio${devidx}=wifi-iface
 			set wireless.default_radio${devidx}.device=radio${devidx}
 			set wireless.default_radio${devidx}.network=lan
 			set wireless.default_radio${devidx}.mode=ap
-			set wireless.default_radio${devidx}.ssid=OpenWrt
+			set wireless.default_radio${devidx}.ssid=${boardname}
 			set wireless.default_radio${devidx}.encryption=none
 EOF
 		uci -q commit wireless
+		sleep 2
+		wifi
 
 		devidx=$(($devidx + 1))
 	done
--- a/package/base-files/files/bin/config_generate	2021-03-02 21:21:49.482682206 +0200
+++ b/package/base-files/files/bin/config_generate	2021-01-22 00:11:49.812136809 +0200
@@ -3,6 +3,9 @@
 CFG=/etc/board.json
 
 . /usr/share/libubox/jshn.sh
+ 
+board=$(cat /tmp/sysinfo/board_name)
+boardname="${board##*,}"
 
 [ -s $CFG ] || /bin/board_detect || exit 1
 [ -s /etc/config/network -a -s /etc/config/system ] && exit 0
@@ -100,7 +103,7 @@
 		static)
 			local ipad
 			case "$1" in
-				lan) ipad=${ipaddr:-"192.168.1.1"} ;;
+				lan) ipad=${ipaddr:-"192.168.10.1"} ;;
 				*) ipad=${ipaddr:-"192.168.$((addr_offset++)).1"} ;;
 			esac
 
@@ -241,8 +244,12 @@
 	uci -q batch <<-EOF
 		delete system.@system[0]
 		add system system
-		set system.@system[-1].hostname='OpenWrt'
-		set system.@system[-1].timezone='UTC'
+		set system.@system[-1].hostname=${boardname}
+		set system.@system[-1].timezone='EET-2EEST,M3.5.0/3,M10.5.0/4'
+		set system.@system[-1].zonename='Europe/Zaporozhye'
+		set system.@system[-1].log_proto='udp'
+		set system.@system[-1].conloglevel='8'
+		set system.@system[-1].cronloglevel='8'
 		set system.@system[-1].ttylogin='0'
 		set system.@system[-1].log_size='64'
 		set system.@system[-1].urandom_seed='0'
@@ -261,7 +268,7 @@
 		json_select system
 			local hostname
 			if json_get_var hostname hostname; then
-				uci -q set "system.@system[-1].hostname=$hostname"
+				uci -q set "system.@system[-1].hostname=$boardname"
 			fi
 
 			if json_is_a ntpserver array; then
--- a/package/base-files/image-config.in	2021-03-02 21:21:49.498681791 +0200
+++ b/package/base-files/image-config.in	2021-01-22 00:11:49.812136809 +0200
@@ -76,7 +76,7 @@
 config TARGET_PREINIT_IP
 	string
 	prompt "IP address for preinit network messages" if PREINITOPT
-	default "192.168.1.1"
+	default "192.168.10.1"
 	help
 		IP address used to configure interface for preinit network
 		messages, including failsafe messages
@@ -92,7 +92,7 @@
 config TARGET_PREINIT_BROADCAST
 	string
 	prompt "Broadcast address for preinit network messages" if PREINITOPT
-	default "192.168.1.255"
+	default "192.168.10.255"
 	help
 		Broadcast address to which to send preinit network messages, as
 		as failsafe messages
@@ -183,7 +183,7 @@
 	config VERSION_REPO
 		string
 		prompt "Release repository"
-		default "http://downloads.openwrt.org/releases/19.07.7"
+		default "http://downloads.openwrt.org/releases/19.07.6"
 		help
 			This is the repository address embedded in the image, it defaults
 			to the trunk snapshot repo; the url may contain the following placeholders:
@@ -259,7 +259,7 @@
 	config VERSION_CODE_FILENAMES
 		bool
 		prompt "Revision code in filenames"
-		default n
+		default y
 		help
 			Enable this to include the revision identifier or the configured
 			version code into the firmware image, SDK- and Image Builder archive
--- a/package/base-files/Makefile	2021-03-02 21:21:49.482682206 +0200
+++ b/package/base-files/Makefile	2021-01-22 00:11:49.812136809 +0200
@@ -81,9 +81,9 @@
 	echo 'pi_init_cmd=$(if $(CONFIG_TARGET_INIT_CMD),$(CONFIG_TARGET_INIT_CMD),"/sbin/init")' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_init_suppress_stderr="$(CONFIG_TARGET_INIT_SUPPRESS_STDERR)"' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_ifname=$(if $(CONFIG_TARGET_PREINIT_IFNAME),$(CONFIG_TARGET_PREINIT_IFNAME),"")' >>$(1)/lib/preinit/00_preinit.conf
-	echo 'pi_ip=$(if $(CONFIG_TARGET_PREINIT_IP),$(CONFIG_TARGET_PREINIT_IP),"192.168.1.1")' >>$(1)/lib/preinit/00_preinit.conf
+	echo 'pi_ip=$(if $(CONFIG_TARGET_PREINIT_IP),$(CONFIG_TARGET_PREINIT_IP),"192.168.10.1")' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_netmask=$(if $(CONFIG_TARGET_PREINIT_NETMASK),$(CONFIG_TARGET_PREINIT_NETMASK),"255.255.255.0")' >>$(1)/lib/preinit/00_preinit.conf
-	echo 'pi_broadcast=$(if $(CONFIG_TARGET_PREINIT_BROADCAST),$(CONFIG_TARGET_PREINIT_BROADCAST),"192.168.1.255")' >>$(1)/lib/preinit/00_preinit.conf
+	echo 'pi_broadcast=$(if $(CONFIG_TARGET_PREINIT_BROADCAST),$(CONFIG_TARGET_PREINIT_BROADCAST),"192.168.10.255")' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_preinit_net_messages="$(CONFIG_TARGET_PREINIT_SHOW_NETMSG)"' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_preinit_no_failsafe_netmsg="$(CONFIG_TARGET_PREINIT_SUPPRESS_FAILSAFE_NETMSG)"' >>$(1)/lib/preinit/00_preinit.conf
 	echo 'pi_preinit_no_failsafe="$(CONFIG_TARGET_PREINIT_DISABLE_FAILSAFE)"' >>$(1)/lib/preinit/00_preinit.conf
--- a/target/linux/sunxi/patches-4.14/212-add-spi-flash-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/212-add-spi-flash-opi-zero.patch	2021-01-22 00:11:49.816136702 +0200
@@ -0,0 +1,48 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -61,6 +70,7 @@
+ 		/* ethernet0 is the H3 emac, defined in sun8i-h3.dtsi */
+ 		ethernet0 = &emac;
+ 		ethernet1 = &xr819;
++		spi0 = &spi0;
+ 	};
+ 
+ 	chosen {
+@@ -381,7 +400,7 @@
+ 
+ &spi0 {
+ 	/* Disable SPI NOR by default: it optional on Orange Pi Zero boards */
+-	status = "disabled";
++	status = "okay";
+ 
+ 	flash@0 {
+ 		#address-cells = <1>;
+@@ -389,6 +400,28 @@
+ 		compatible = "mxicy,mx25l1606e", "winbond,w25q128";
+ 		reg = <0>;
+ 		spi-max-frequency = <40000000>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <0x01>;
++			#size-cells = <0x01>;
++
++			partition@0 {
++				label = "uboot";
++				reg = <0x0 0x80000>;
++			};
++
++			partition@80000 {
++				label = "dtb";
++				reg = <0x80000 0x10000>;
++			};
++
++			partition@90000 {
++				compatible = "denx,uimage";
++				label = "firmware";
++				reg = <0x90000 0x0f70000>;
++			};
++		};
+ 	};
+ };
+ 
--- a/target/linux/sunxi/patches-4.14/213-add-i2c-opi-zero.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/target/linux/sunxi/patches-4.14/213-add-i2c-opi-zero.patch	2021-01-22 00:11:49.816136702 +0200
@@ -0,0 +1,11 @@
+--- a/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
++++ b/arch/arm/boot/dts/sun8i-h2-plus-orangepi-zero.dts
+@@ -62,6 +70,8 @@
+ 		ethernet0 = &emac;
+ 		ethernet1 = &xr819;
+ 		spi0 = &spi0;
++		i2c0 = &i2c0;
++		i2c1 = &i2c1;
+ 	};
+ 
+ 	chosen {
--- a/feeds.conf.default	2021-03-02 21:21:49.474682414 +0200
+++ b/feeds.conf.default	2021-02-18 01:55:04.546158903 +0200
@@ -1,5 +1,11 @@
-src-git packages https://git.openwrt.org/feed/packages.git^90af10d01579425369bd474051b6d3ddaf32a7e3
-src-git luci https://git.openwrt.org/project/luci.git^34e0d656a41befd9720be35c4831c9f136a67c59
-src-git routing https://git.openwrt.org/feed/routing.git^e26b4745209655976b7d124465b1dc53ade632f9
+src-git packages https://git.openwrt.org/feed/packages.git^90af10d01579425369bd474051b6d3ddaf32a7e3
+src-git luci https://git.openwrt.org/project/luci.git^34e0d656a41befd9720be35c4831c9f136a67c59
+src-git routing https://git.openwrt.org/feed/routing.git^e26b4745209655976b7d124465b1dc53ade632f9
 src-git telephony https://git.openwrt.org/feed/telephony.git^6e019c94d0fa7162548d528bf4ba060a61f8cb59
-src-git freifunk https://github.com/freifunk/openwrt-packages.git^c621a4283870fe062489fe5e26a15deda7ef4ed7
+src-git freifunk https://github.com/freifunk/openwrt-packages.git^c621a4283870fe062489fe5e26a15deda7ef4ed7
+#src-git video https://github.com/openwrt/video.git
+#src-git targets https://github.com/openwrt/targets.git
+#src-git management https://github.com/openwrt-management/packages.git
+src-git oldpackages http://git.openwrt.org/packages.git
+src-git opicyberwrt https://github.com/melsem/opi-zero-cyberwrt.git
+src-git diskman https://github.com/melsem/luci-app-diskman.git
--- a/feeds/packages/utils/triggerhappy/patches/001-add_REL-ABS-devices.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/feeds/packages/utils/triggerhappy/patches/001-add_REL-ABS-devices.patch	2021-02-28 11:11:04.490962000 +0200
@@ -0,0 +1,12 @@
+--- a/devices.c
++++ b/devices.c
+@@ -45,7 +45,8 @@
+ 	int rc = ioctl(fd, EVIOCGBIT(0,sizeof(bits)), bits);
+ 	return rc > 0 && (
+ 		/* we only consider devices with keys or switches suitable */
+-		test_bit(EV_KEY, bits) || test_bit(EV_SW, bits)
++		test_bit(EV_KEY, bits) || test_bit(EV_SW, bits) ||
++		test_bit(EV_REL, bits) || test_bit(EV_ABS, bits)
+ 	);
+ }
+ 
